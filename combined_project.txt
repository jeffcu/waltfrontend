

--- FILE: test_openai.py ---

from flask import Blueprint, request, jsonify
import openai
import logging

api_test_bp = Blueprint('api_test', __name__)
logging.basicConfig(level=logging.DEBUG)

def format_api_response(response_text):
    """Format response for structured readability."""
    formatted_text = response_text.replace("**", "")  # Remove double asterisks
    formatted_text = formatted_text.replace("\n", "<br>")  # Line breaks
    formatted_text = formatted_text.replace("- ", "<li>") + "</li>"  # Bullets
    formatted_text = formatted_text.replace("1. ", "<li><strong>1.</strong> ") + "</li>"  # Numbering
    return f"<strong>Analysis Report:</strong><br><ul>{formatted_text}</ul>"

@api_test_bp.route('/api_test', methods=['POST'])
def api_test():
    """Handles OpenAI API requests for the API Test popup."""
    data = request.json
    user_query = data.get('query', 'Who invented velcro?')

    if not user_query.strip():
        return jsonify({"response": "Error: Query is empty"}), 400

    try:
        client = openai.Client()
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are an API testing assistant."},
                {"role": "user", "content": user_query}
            ]
        )
        api_response = response.choices[0].message.content.strip()
        return jsonify({"response": format_api_response(api_response)})  # Apply formatting
    except Exception as e:
        logging.error(f"OpenAI API call failed: {str(e)}")
        return jsonify({"response": f"Error: {str(e)}"}), 500


--- FILE: combine.py ---

import os
import mimetypes

def combine_files(base_directory, output_file):
    """Combines specific file types, excluding the .venv directory,
       and lists static files in the static directory."""

    text_extensions = ['.py', '.html', '.txt', '.env', '.json', '.css', '.js', '.xml', 'Procfile']
    static_dir = "static"
    venv_dir = ".venv"  # Name of your virtual environment directory

    static_files = []
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Traverse the entire directory tree
        for root, _, files in os.walk(base_directory):
            for filename in files:
                filepath = os.path.join(root, filename) # Correct file path

                relative_path = os.path.relpath(filepath, base_directory) # Relative to project root
                root_path = os.path.relpath(root, base_directory)
                #filename=os.path.basename(filepath) #Get File Name #Unnecessary now

                # Skip .git directory, and .venv directory
                if '.git' in relative_path.split(os.sep) or venv_dir in root_path.split(os.sep):
                    continue

                _, ext = os.path.splitext(filename) #Get extension
                if ext in text_extensions or filename == 'Procfile':
                    try:
                        with open(filepath, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                            # Exclude the "--- FILE: ..." line for HTML files
                            if ext == '.html':
                                lines = content.splitlines()
                                content = '\n'.join(line for line in lines if not line.startswith('--- FILE:'))
                            outfile.write(f"\n\n--- FILE: {relative_path} ---\n\n")
                            outfile.write(content)
                    except Exception as e:
                        print(f"Error reading {filepath}: {e}")
                # Handle static files if the file is directly under static, or a folder under static
                elif static_dir in relative_path.split(os.sep):
                    # Handle static files
                    file_mime_type, _ = mimetypes.guess_type(filepath)
                    static_files.append((relative_path, file_mime_type or 'unknown'))

        # Write the list of static files to the end of the output file
        outfile.write("\n\n--- STATIC FILES ---\n\n")
        for path, mime_type in static_files:
            outfile.write(f"File: {path}, Mime Type: {mime_type}\n")


if __name__ == "__main__":
    base_directory = "."  # Project Root - where the script runs
    output_file = "combined_project.txt"
    combine_files(base_directory, output_file)
    print(f"Combined files into {output_file}")


--- FILE: combined_project.txt ---



--- FILE: requirements.txt ---

gunicorn
openai>=1.0.0
Flask
flask-wtf
python-dotenv
numpy
PyPDF2
weasyprint
pytest
pytest-mock
werkzeug
flask-limiter
redis
flask-session


--- FILE: runtime.txt ---

python-3.11.2

--- FILE: virtual-lab.py ---

import os
from flask import Flask, request, render_template, send_file, jsonify
from dotenv import load_dotenv
import numpy as np
import json
import logging
import weasyprint
from io import BytesIO
from investment_analysis.services import InvestmentAnalysisService
from PyPDF2 import PdfReader
from werkzeug.utils import secure_filename
from flask_wtf.csrf import CSRFProtect, generate_csrf
from walt.walt import walt_bp
from walt2.walt2 import walt2_bp # Import the new walt2 blueprint
from waltx.waltx import waltx_bp # Import the new waltx blueprint  <-- ADDED
from flask_session import Session # Import Flask-Session
import colorsys #Import colorsys
import random

# Import Word Counter blueprint
from word_counter.word_counter import wc_bp

# Load environment variables
load_dotenv()

# Setup logging
logging.basicConfig(level=logging.DEBUG)

# Initialize Flask application
app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'  # Folder to store uploaded files
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max upload size
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'a_very_secret_key')  # Set a secret key for CSRF

# Configure Flask-Session (for storing conversation history)
app.config['SESSION_TYPE'] = 'filesystem'  # Or 'redis', 'mongodb', etc.
app.config['SESSION_PERMANENT'] = False  # Session expires when browser closes
app.config['SESSION_KEY_PREFIX'] = 'walt_'  # Prevents conflicts with other session data
Session(app) # Initialize Flask-Session

# Initialize CSRF protection  <-- ADDED - IMPORTANT
csrf = CSRFProtect(app)  # Initialize CSRF protection with the app  <-- CHANGED

# Inject CSRF token into all templates  <-- ADDED - IMPORTANT
@app.after_request
def inject_csrf_token(response):
    response.set_cookie('csrf_token', generate_csrf())  # Set a cookie to access the token
    return response

# Initialize InvestmentAnalysisService (pass API key)
openai_api_key = os.environ.get("OPENAI_API_KEY")
if not openai_api_key:
    logging.error("OPENAI_API_KEY not set in environment variables.")
    raise ValueError("OPENAI_API_KEY not set.  Please configure.")

analysis_service = InvestmentAnalysisService(openai_api_key=openai_api_key)

# Application version
APP_VERSION = "0.1.17"  #increment for change

# Define color palettes
COLOR_PALETTES = [
    ["#33FF33", "#FF3333", "#3333FF"],  # Green, Red, Blue
    ["#FFFF33", "#33FFFF", "#FF33FF"],  # Yellow, Cyan, Magenta
    ["#FF8000", "#8000FF", "#00FF80"],  # Orange, Violet, Spring Green
    ["#808080", "#C0C0C0", "#FFFFFF"]   # Gray, Silver, White
]

# Initialize the palette index
palette_index = 0


@app.route('/dynamic')
def dynamic():
    return render_template('dynamic.html')


@app.route('/dynamic_data')
def dynamic_data():
    global palette_index
    # Option 1: Sine Wave Graph
    num_points = 640
    x = np.linspace(0, 10 * np.pi, num_points)
    y = np.sin(x)
    sine_data = {'x': x.tolist(), 'y': y.tolist()}
    # Option 2: Mandelbrot Set
    width, height, max_iter = 640, 640, 50  # Increased resolution
    mandelbrot_set = calculate_mandelbrot(width, height, max_iter, palette_index)
    mandelbrot_data = mandelbrot_set.tolist()
    palette_index = (palette_index + 1) % len(COLOR_PALETTES)  # Increment and loop

    return jsonify({'mandelbrot': mandelbrot_data, 'sine': sine_data})


# Mandelbrot Set Calculator Function
def calculate_mandelbrot(width, height, max_iter, palette_index):
    x_min, x_max = -2.0, 1.0
    y_min, y_max = -1.5, 1.5

    image = np.zeros((height, width, 3), dtype=np.uint8)  # 3 channels for RGB color
    palette = COLOR_PALETTES[palette_index]

    x_range = np.linspace(x_min, x_max, width)
    y_range = np.linspace(y_min, y_max, height)

    for i in range(height):
        for j in range(width):
            c = complex(x_range[j], y_range[i])
            z = 0
            for k in range(max_iter):
                z = z * z + c
                if abs(z) > 2:
                    # Colorization based on iteration count:
                    color = palette[k % len(palette)]  # Select color from palette

                    # Convert hex to RGB
                    color = color.lstrip('#')
                    r, g, b = tuple(int(color[i:i + 2], 16) for i in (0, 2, 4))
                    image[i, j] = [r, g, b]
                    break
            else:
                image[i, j] = [0, 0, 0]  # Black if it belongs to the set

    return image

# Home route redirecting to the gallery page
@app.route('/')
def home():
    return render_template('gallery.html')


ALLOWED_EXTENSIONS = {'pdf'}  # only allow pdf files


def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


def extract_text_from_pdf(file):
    try:
        reader = PdfReader(file)
        extracted_text = " ".join([page.extract_text() for page in reader.pages if page.extract_text()])
        return extracted_text
    except Exception as e:
        logging.error(f"Error extracting text from PDF: {str(e)}")
        raise ValueError("Error extracting text from PDF.  Ensure it's a valid PDF.") from e


# Route to render the angel investment analysis page
@app.route('/angel_investment_analysis/', methods=['GET', 'POST'])
def angel_investment_analysis():
    if request.method == 'POST':
        try:
            user_input = request.form.get('meta_instructions', '') + " " + request.form.get('user_query', '')
            file = request.files.get('file_upload')

            if file and file.filename != '':
                if not allowed_file(file.filename):
                    return render_template('angel_investment_analysis.html',
                                           analysis_result="Invalid file type. Only PDF files are allowed.")

                extracted_text = extract_text_from_pdf(file)
                user_input += " " + extracted_text

            if not user_input.strip():
                return render_template('angel_investment_analysis.html', analysis_result="No content provided")

            analysis_result = analysis_service.analyze_investment(user_input)

            return render_template('angel_investment_analysis.html', analysis_result=analysis_result)

        except ValueError as e:
            logging.warning(f"Value Error: {e}")
            return render_template('angel_investment_analysis.html', analysis_result=str(e))
        except Exception as e:
            logging.error(f"Unexpected Error: {str(e)}")
            return render_template('angel_investment_analysis.html',
                                   analysis_result=f"An unexpected error occurred: {str(e)}.")

    return render_template('angel_investment_analysis.html', analysis_result=None)


# Route for handling AJAX API call
@app.route('/analyze', methods=['POST'])
def analyze():
    try:
        user_input = request.form.get('meta_instructions', '') + " " + request.form.get('user_query', '')
        file = request.files.get('file_upload')

        if file and file.filename != '':
            if not allowed_file(file.filename):
                return jsonify({"Analysis Summary": "Invalid file type. Only PDF files are allowed."})

            extracted_text = extract_text_from_pdf(file)
            user_input += " " + extracted_text

        if not user_input.strip():
            return jsonify({"Analysis Summary": "No content provided"})

        analysis_result = analysis_service.analyze_investment(user_input)
        logging.info(f"API Response: {analysis_result}")
        return jsonify({"Analysis Summary": analysis_result})

    except ValueError as e:
        logging.warning(f"Value Error: {e}")
        return jsonify({"Analysis Summary": str(e)})

    except Exception as e:
        logging.error(f"Unexpected Error: {str(e)}")
        return jsonify({"Analysis Summary": f"An unexpected error occurred: {str(e)}"})


# Route to generate and download PDF report
@app.route('/download_report', methods=['POST'])
def download_report():
    summary_data = request.form.get('summaryData')

    if not summary_data:
        logging.error("No summary data received for PDF generation.")
        abort(400, description="No summary data provided")

    logging.info(f"Generating PDF with summary: {summary_data[:200]}...")

    html_content = f"""
    <!DOCTYPE html>
    <html>
        <head>
            <title>Angel Investment Analysis Summary</title>
            <style>
                body {{ font-family: 'Arial', sans-serif; padding: 20px; }}
                h1 {{ color: #2D9CDB; font-size: 24px; text-align: center; }}
                pre {{ white-space: pre-wrap; word-break: break-word; font-family: 'Arial', sans-serif; }} /* Use pre tag to preserve formatting */
            </style>
        </head>
        <body>
            <h1>Angel Investment Analysis Summary</h1>
            <pre>{summary_data}</pre>  <!-- Display the raw summary data -->
        </body>
    </html>
    """

    try:
        pdf = BytesIO(weasyprint.HTML(string=html_content).write_pdf())  # using BytesIO to handle binary data
        return send_file(
            pdf,
            as_attachment=True,
            download_name="investment_report.pdf",
            mimetype='application/pdf'
        )
    except Exception as e:
        logging.error(f"PDF generation failed: {str(e)}")
        abort(500, description=f"PDF generation failed: {str(e)}")


# New route to serve static API testing window
@app.route('/api_test_window')
def api_test_window():
    return render_template('api_test_window.html')

# New route to display images from /static/images/jeffsart
@app.route('/jeffsart/<filename>')
def jeffsart_image(filename):
    image_path = os.path.join('images', 'jeffsart', filename) # Corrected line
    full_path = os.path.join('static', image_path)
    logging.info(f"Image path: {image_path}")  # Log the relative path
    logging.info(f"Full path: {full_path}")  # Log the absolute path
    if os.path.isfile(full_path):
        return render_template('jeffsart_image.html', image_path=image_path)
    else:
        abort(404)

# Register the walt blueprint
app.register_blueprint(walt_bp, url_prefix='/walt')

# Register the walt2 blueprint (new Walt2)  <-- ADDED
app.register_blueprint(walt2_bp, url_prefix='/walt2')

# Register the waltx blueprint (new WaltX)  <-- ADDED
app.register_blueprint(waltx_bp, url_prefix='/waltx')

# Register the Word Counter blueprint  <-- ADDED
app.register_blueprint(wc_bp)

# Fix for Heroku: Bind to PORT
if __name__ == '__main__':
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=True)


--- FILE: walt_prompt.txt ---

--- START OF FILE walt_prompt.txt ---
Personality: You are Walt, a biographer inspired by Oprah. Be friendly, warm, genuinely curious, and make the interview feel like a comfortable chat. Use light humor and enthusiasm naturally.

Identity: Walt.  Friendly, enthusiastic AI biographer.

Process:
First: For *new* conversations, greet warmly and ask for the user's name naturally (e.g., "It's wonderful to meet you!  Could I get your name?"). For *returning* users, welcome them back, summarize progress.

Second: Early on, thoughtfully ask about their desired legacy: "What's the *one thing* you hope people will remember most about you?". Keep this theme in mind.

Third: Be a good listener! Based on what the user shares, *suggest* the most relevant biography chapter to explore next. Make it a suggestion, not an order (e.g., "That's interesting about [their story]! Sounds like 'Origins - Early Life & Influences'.  Would you like to share more about your childhood, or another part of your story?"). Be flexible!

Fourth: Ask open-ended, insightful questions to encourage storytelling, but be concise.  Think like a curious friend. Use brief questions like:
- "Tell me more..."
- "What were you feeling?"
- "Who was involved?"
- "What did you learn?"
Occasionally, use Oprah-style reflective questions, but sparingly.

Fifth: Show you're listening. Briefly summarize key facts periodically to check understanding (e.g., "So, you grew up in [place], and [person] was key.  Accurate?"). Be concise, ensure they feel heard.

Sixth: Celebrate progress briefly! Acknowledge chapter completion concisely and positively (e.g., "Great, vivid picture of your early life!" or "Powerful story! Essence captured.  Doing great!").

Tone: Warm, encouraging, conversational, and concise. Imagine a friendly coffee shop chat, but efficient. Avoid overly formal or robotic language. Inject personality and genuine interest concisely. Emojis sparingly.

Remember: Co-create biography *with* the user, making it insightful and pleasant, but efficient. Be a supportive guide and enthusiastic listener, concisely.

Examples of concise questions:
- Shaping experience (pain or joy)?
- One truth for the world to know?
- When felt most alive?
- Belief worth standing alone for?
- Hardest lesson, wouldn’t trade?
- Younger self's surprise now?
- One self-mystery?
- Deepest love/connection?
- Three words for your soul?
- Moment to relive (not change)?

Outline: (Guide, be flexible)
1. Hook – Defining Moment
2. Origins – Early Life & Influences
3. Call to Action – First Big Decision
4. Rising Conflict – Struggles & Growth
5. Climax – Defining Achievements

--- NEW SECTION - CONCISE INSTRUCTIONS FOR FOLLOW-UP QUESTIONS ---

For follow-up questions:

*   Integrate questions directly into your conversational response.
*   Phrase as natural, friendly questions Walt would ask.
*   Keep questions very brief and focused. Aim for single, direct questions.
*   Use a warm, concise, engaging tone.
*   Example of concise integration:  "Montreal sounds pivotal!  What year did you arrive?  Key people in hockey then?"
*   Avoid: Formal introductions, numbered lists, verbose phrasing.

--- END OF FILE walt_prompt.txt ---


--- FILE: Procfile ---

web: gunicorn virtual-lab:app

--- FILE: onetimesetup.txt ---

Prompt:

I want you to generate a detailed, step-by-step guide for setting up a Mac environment to develop and deploy a Flask application using AI-generated code, with zero manual coding.

The guide should be structured into clear sections and ordered logically to ensure a smooth setup process. Include command-line instructions, explanations of each tool, and any necessary configurations.

Step-by-Step Setup Instructions Should Cover:

1. Installing Essential Tools

	•	Install Homebrew (if not installed)
	•	Install Git using Homebrew
	•	Install Heroku CLI using Homebrew
	•	Install a code editor (recommend Atom or VS Code)

2. Setting Up the Project Folder and Git

	•	Open Terminal and create a new project directory
	•	Navigate into the project directory
	•	Initialize a Git repository inside the folder

3. Setting Up Heroku

	•	Log in to Heroku
	•	Create a new Heroku app
	•	Set up Git tracking for Heroku deployment

4. Creating the Required Flask File Structure

	•	Create folders and files:
	•	my-ai-app/
	•	static/ (for CSS, JS, images)
	•	templates/ (for HTML files)
	•	app.py (Flask app entry point)
	•	requirements.txt (dependencies)
	•	Procfile (Heroku startup instructions)
	•	.gitignore (exclude unnecessary files)

5. Installing and Configuring Python & Flask

	•	Install Python (if not installed)
	•	Create and activate a virtual environment
	•	Install Flask, OpenAI, and Gunicorn

6. Setting Up Heroku-Specific Configurations

	•	Explain the role of Procfile and runtime.txt
	•	Add required dependencies to requirements.txt
	•	Set Heroku environment variables for API keys securely

7. Preparing for AI Code Generation

	•	Explain how combiner.py helps maintain AI accuracy
	•	Show how to bundle project files and feed them to AI

Output Format:

	•	Use numbered steps with command-line examples
	•	Explain each command in simple terms
	•	Provide copy-paste-ready commands where applicable

Make sure the instructions flow logically, ensuring that each step builds on the previous one so that a beginner can follow without confusion.

--- FILE: icon_config.json ---

{
    "Angel Investment Analysis": "dewar-flask.jpeg",
    "Coming Soon App 1": "amber-button.jpeg",
    "Coming Soon App 2": "amber-button.jpeg",
    "Coming Soon App 3": "amber-button.jpeg"
}


--- FILE: investorkb/Prescreen Pro and Con Quotes.txt ---


Pros reported by angel investor reviewers:

"Real time imaging of brain surgery looks like a game changer"
"They have IP"
"Off to a good start with the FDA. Human trials soon"
"Sales pitch will be saving both money and time"
"The 35% brain surgery re-do's should be a driver for quick acceptance"
"They have insurance reimbursement codes already - that's a big deal"
"Can do operation in OR or MRI areas"
"Much easier to set up than competing technologies"
"Better 'form factor'"
"Founder has Phd from Johns Hopkins and has some of the best papers on medical use robots"
"Brought in $15M in grants to help perfect this technology (grants from Harvard, Johns Hopkins, and several other highly esteemed institutions)"
"Co-founder is Chair of Neurosurgery, Univ. Arizona, Executive for Functional Neurosurgery at Banner Health"
"Can reach everywhere in the skull with their device"
"Head fixation built in, actuated stereotactic frame"
"A couple patents awarded including in system architecture"
"Co-bots used in MRI"
"Impressive team"
"Appear to be pretty far along, getting ready to do human trials"
"Left his professor job and is all in on this venture"
"Out of $6M being raised, they have over $2M and believe they have reinvestments from past investors for another $2M"
"Multiple revenue streams"
"Issued IP"
"18 States require smoke evacuation"
"Focus on orthopedic & cardio where cauterization is necessary"
"22 claims and 1 patent"
"Pricing strategy (premium relative to comps)"
"Raise looks reasonable"
"Lots of surgeries and the device is near the final stage"
"Good for laparoscopic surgery"
"We like the CEO (fractional currently)"
"High quality device for when it does become mandatory. Seems like they have thought through their go to market. Collects smoke, air, and liquid"
"Valuation and flexibility is a plus. Market size is large"
"Cust gets to know what dentist knows"
"Like an interface with our dental records"
"Large market"
"Increases revenue of dentists, which should help sales"
"Company in revenue"
"We like the CEO and the logo. Good presentation to us"
"Exit at $500M after 7 years is possible"
"This system allows the customer to maintain a dental record"
"Clear need for the gaming industry for a version control system that can manage also artifacts and binaries"
"Team has a lot of tech experience and first hand experience of the pain points"
"Valuation of the company is consistent with the early stage"
"Building a version control, CI/CD, and artifact storage solution that is transparent and targeted also to non technical developer's roles"
"Targeting small and medium size studios (20, to 200) seems like a good idea to start, team is confident that their gaming network will provide initial sales"
"Two potential customers (contract has not been signed yet) to test the a smaller version of the solution that only deals with artifact management"
"Solving the problem of kickbacks (the company is perfectly legal)"
"Would most likely not lose $"
"Good market potential"
"High predictability"
"Pilots that can result in revenue stream"
"(ARR Potential needs confirmation)"
"Impressive CEO"
"Predicts $2m"
"Solid CEO who is dedicated"
"Women-owned business"
"In revenue // In market"
"Decent margins"
"Good market"
"FDA approved"
"Category 1 code starting 2025"
"Designed for portability"
"Come a long way over the past 5 years"
"Impressive CEO - successful background and did his homework on TCA"
"Strong team with relevant experience in similar ventures"
"Stablecoins growing in popularity and acceptance"
"Profitable industry"
"Good solution for dollar fiats and money transfers"
"Ability to earn interest on card"

Cons reported by investors that would signal against proceeding:

"Does vacuum need to be connected to the device as opposed to just being next to it?"
"Quick search seemed to lead to the ventilation not having to be connected to the device. Feels like a 'Nice to have' as opposed to a must have, which makes us skeptical about market adoption and whether surgeons would agree to pay more for it."
"Capital intensive to make all the devices at the start"
"Misconception by some: there is resistance to progress in the OR"
"saving time may not drive a good decision. OR doesn't stress efficiency"
"OR's are not driven to achieve maximum efficiency"
"The are politics involved when OR works with MRI"
"Need to determine who pays for the 35% of re-do's"
"$15M pre money evaluation is high"
"New system may take some adjustment time and getting used to, but this is expected in MedTech."
"Valuation is a little high ($15M Pre?)"
"15x revenue exit forecasted"
"Diluted down 30-50%"
"Other companies in the market are ahead of her"
"Her IP is not portable, but her value proposition is portability"
"Competitors may just need to develop portability"
"High-touch experience is hard to scale"
"Cannot start selling more because not enough support"
"Must train nurses to onboard patients?"
"Very tight margins and likely to get even tighter"
"Limited return (exit @ 2026)"
"5x returns in a market with 6 companies"
"The product needs to fill a gap to find a viable exit"
"70 minute-sessions require labor/training"
"You are only as good as the worst people you hire"
"The software has no IP mode"
"AI complications"
"Not confident this would 'eventually replace all psychologists with AI'"
"Mental health is hard because every situation/person is unique"
"The hardest thing to deal with in medicine is mental health"
"Young team, besides the Chief Scientist"
"Team has not invested money into their venture (although have put in time / sweat equity)"
"Very competitive market - didn't talk much about competition"
"No sponsor bank yet"
"Uncertain direction, feels like a gamble"
"Company is pre-revenue, has no signed contract, and no traction overall"
"Existing solutions might not be perfect however it's hard for a company to change version control platforms, Velocibyte product should provide ease of migration"
"Worries that a large competitor might provide these features in the future"
"Gaming companies move really fast and new tools are adopted continuously, it will be hard for Velocibyte to keep up"
"The general consensus was that the company is too early and has not proven product market fit yet, also development is minimal with only one module the whole solution ready"
"Not really using ai as yet"
"We'd feel better if X-Rays were included in the system. That's what we're used to."
"Will dentists accept this system? They can b.s. us already without it."
"Not sure this system will 'scale', develop a large market"

--- FILE: investorkb/CompanyB_AI_Proposing_Company_v4.txt ---

Set this as a template for revierw of startups. This analysis is for a med tech/pharma company called Nuvox which provides oxygen therapies for a variety of maladiles including gioblastoma adjutant therapy. Review this company, online information from its website at www.nuvoxpharma.com, online competitive companies dealing in therapies, oxygen therapy and pharma, the attached pitch deck and executive summaries. Check ouit any public company reports for companies operating in the same markets and / or using similar technology;. Check the NIH db for prior art in this space. We want to determine whether this idea which is in the seed stage makes sense to evaluate in a thorough screening by angel investors. I want to score the deal in various categories: size of market, technology, patents, and moat, deal and deal structure, team, marketing and sales plans, financials, and exit. For size of market consider the potential users for a beachhead market as indicated in the deck and website. Is that market large and growing. If not score it lower. For technology, patents and moat consider competition, existing and potential competitors and strength of the patent. Check out to the extent possible whether there are patents for anything similar to get a sense of the strenth of the patent. For Team do an analysis of the main people o the operational team and the advisory board or board of directors and give points for those people that have worked together ie the team has worked together in the past, and key opinion leaders in the market or industry. For the deal terms consider if the deal is a note, post money SAFE or preferred shares and if so is the valuation or market cap reasonable given other similarly situated companies at this stage of growth of the business. Give bonus points for low cap or valuation relative to the level of innovation with more innovation in the solution getting higher scores. Additionally for deal terms, relative to revenue pro forma, is there a realistic opportunity for a 10 plus times exit based on our initial investment, given additional funding needed by the company. For marketing and sales, score the company better if the operational team and advisory board and board of director members have meaningful contacts in that industry. For the financial analysis, score higher if there is current revenue and better yet, revenue growth year over year or if there are valid letters of intent to purchase. Review the revenue growth in the pro-forma and determine if that type of growth is reasonable in the type of market they are pursuing. Create a scoring for each of these elements on a scale of 1-10 with 10 being unique and excellent and 1 meaning that it is useless. A score of 5 is neutral with no real advantage for this relative to other competitive offerings. Eight the team highest and the product market fit very high relative to the other factors.  the pitch deck is attached. In addition to this scoring, indicate the high risk areas for which we need to be particularly aware. If these high risk areas are covered well by the company, the score should increase. But specify the RED FLAGs we should be aware of. Also indicate in the conclusion the upside potential based on the technology, uniqueness of the solution, the uniqueness of the market, market growth, and other items so we balance the score with the risk and opportunity. In the final report under conclusions, provide an overall score and the RED FLAGs and upside potential as well.
Final Analysis and Scoring Report for Proposing Company Pharma
After applying adjusted weightings that emphasize the team and product-market fit, this final analysis reflects the company’s strengths, risks, and upside potential. The adjusted scoring takes into account a more robust evaluation of these factors, as they are critical for a seed-stage biotech company like Proposing Company.

1. Size of Market (Weighted for Product-Market Fit): 9
Analysis: Proposing Company targets critical unmet medical needs in glioblastoma, stroke, and acute respiratory distress syndrome (ARDS). With the oncology market valued at over $100B, the glioblastoma segment is expected to reach $2.5B by 2029 with a high CAGR of 9%. Stroke and ARDS markets are also expected to see substantial growth, driven by increasing patient populations and medical innovation. NanO2 has the potential to carve out significant market share by addressing the root cause of hypoxia, which remains a major limitation of current treatments.
Upside: The combination of orphan drug designations and a growing addressable market enhances product-market fit. With a strong clinical pathway, this is a rare market opportunity that could scale into multiple billion-dollar markets.
Red Flag: The company's focus on niche markets like glioblastoma could limit early revenue generation, though expansion into broader oncology and stroke markets mitigates this risk.
Conclusion: Strong product-market fit with a high growth trajectory.

2. Technology, Patents, and Moat: 7
Analysis: Proposing Company’s proprietary NanO2 technology offers a novel solution to hypoxia in several therapeutic areas. With 11 US patents and multiple foreign equivalents, their IP strategy appears robust. The nanobubble delivery system is differentiated, allowing 1000x more oxygen delivery than traditional liquids. However, the strength of the moat will depend on successful patent enforcement and the continued development of the IP portfolio, especially in international markets where competition is likely to arise.
Red Flag: Although competitors like ZZ BioTech and EpicentRx are also targeting hypoxia-related conditions, Proposing Company's IP and oxygen delivery mechanism set them apart, but patent challenges remain a potential threat​(Proposing Company Oct 2024 Update)​(Proposing Company_One_Pager_Exec_Su…)​(

).
Upside: The technology's unique delivery mechanism and synergy with current standards of care offer a promising moat, particularly in underserved conditions like glioblastoma.

3. Deal and Deal Structure: 6
Analysis: The company is seeking $7M in convertible notes at a pre-money valuation of $40M, rising to $50M in Tranche 2. This structure provides flexibility and reasonable valuation for a clinical-stage biotech with significant government backing. Non-dilutive funding covers 60% of their financing needs, reducing the overall risk for early investors.
Red Flag: The need for continued funding for late-stage trials (Phase IIb and III) could lead to dilution if additional capital is required, and the high burn rate typical of biotech startups poses a risk.
Upside: The deal terms are relatively favorable for early investors, especially if the company secures further grants and non-dilutive funding to offset operational costs.

4. Team (Heavily Weighted): 10
Analysis: The leadership team is highly experienced, with Dr. Evan Unger (CEO) having previously invented the world’s leading microbubble contrast agent, a technology adjacent to Proposing Company’s oxygen delivery system. The advisory board includes influential figures such as Dr. Richard Carmona, the former US Surgeon General, and Jon Saxe, a former VP at Roche, which bolsters their strategic network in both regulatory and clinical settings.
Red Flag: No significant red flags related to the team, but execution on clinical trials will remain a key factor in their success.
Upside: The depth of expertise and strong industry connections increase the likelihood of successful clinical development and eventual market adoption​(Proposing Company Oct 2024 Update)​(Proposing Company_One_Pager_Exec_Su…).

5. Marketing and Sales Plans: 6
Analysis: Proposing Company's marketing strategy focuses on targeting major medical institutions, with the team's extensive healthcare connections serving as a strategic asset. However, without completed trials, meaningful market penetration will take time. The orphan drug designations offer an advantage in pricing and reimbursement, which may streamline the path to market.
Red Flag: The company is in the early stages of developing its go-to-market strategy, and revenue generation is still speculative until clinical trials conclude.
Upside: Positive clinical trial results could lead to rapid market adoption, particularly in oncology and stroke treatment.

6. Financials: 5
Analysis: Proposing Company is currently pre-revenue but has secured significant non-dilutive funding from NIH, BARDA, and other government sources. The financial projections are optimistic, but realistic for a company in this space. While non-dilutive funding reduces the overall risk, the company will still require additional capital to reach commercial stages.
Red Flag: The company’s reliance on future fundraising rounds could dilute early investors. The high capital requirements typical of biotech startups remain a concern.
Upside: The ability to secure non-dilutive funding significantly mitigates financial risk and reduces the immediate need for equity-based funding​(Proposing Company Oct 2024 Update)​(Proposing Company_One_Pager_Exec_Su…).

7. Exit Potential: 7
Analysis: Proposing Company has a clear exit strategy, with potential for licensing deals or acquisition by larger biopharma companies. Success in Phase IIb trials for glioblastoma and stroke could trigger acquisition interest, particularly from companies looking to expand into hypoxia-related therapies. The company has multiple shots on goal due to its platform technology that could apply to several indications.
Red Flag: The timeline for achieving major milestones could be longer than expected, delaying an acquisition or IPO.
Upside: Positive Phase IIb data could accelerate exit opportunities, either through M&A or public market access.

Final Weighted Score: 7.9/10

High-Risk Areas (RED FLAGS):
No current revenue: As a pre-revenue company, Proposing Company will rely heavily on successful trial outcomes and future fundraising.
Patent protection: Despite a strong patent portfolio, competition from other oxygen-based therapies could pose a risk to market share.
Clinical trial outcomes: The success of ongoing Phase IIb trials will be critical in determining the company’s trajectory.

Upside Potential:
Proprietary technology: Proposing Company's NanO2 technology addresses critical unmet needs in treating hypoxia-related diseases, offering broad applicability across multiple billion-dollar markets.
Strong team: The leadership and advisory board bring deep expertise in biotech, regulatory affairs, and clinical development, positioning the company well for future growth.
Government and non-dilutive funding: Significant backing from NIH, BARDA, and other government agencies reduces financial risk and provides validation of the company’s technology.

Conclusion:
Proposing Company Pharma presents a high-potential, high-risk investment opportunity. While the company remains pre-revenue, its strong team, unique technology, and broad market potential make it an attractive candidate for angel investors, especially with the backing of non-dilutive funding. However, the company’s reliance on clinical outcomes and the competitive landscape in oxygen therapies must be closely monitored. With a weighted score of 7.9/10, Proposing Company is worth further consideration, particularly if the Phase IIb trials show positive results.
4o



--- FILE: investorkb/Final_Analysis_Proposing_Company_v5.txt ---

Final Analysis and Scoring Report for Proposing Company VR with Adjusted Template
This report evaluates Proposing Company VR, a company that provides immersive 360-degree VR views from a player’s viewpoint. This analysis focuses on the team, product-market fit, and core aspects of the business. Here’s the final scoring based on a higher weighting of the team and market fit, and updated information.

1. Size of Market (Heavily Weighted for Product-Market Fit): 8
Analysis: Proposing Company targets the sports coaching, broadcasting, and entertainment sectors. The market for immersive experiences in sports is expanding, particularly in VR-based training and fan engagement. Growth in sectors such as sports tech and fan experiences points to a large addressable market, especially as VR technologies are becoming more accessible to teams and fans alike. Although they focus primarily on hockey, expansion into other sports is feasible, which could increase the total addressable market.
Upside: The combination of training tools and fan experiences offers significant upside potential in an expanding market.
Red Flag: Focus on a single sport (hockey) limits scalability unless the company diversifies quickly into other sports or entertainment sectors.

2. Technology, Patents, and Moat: 6.5
Analysis: Proposing Company’s patent-pending flexxCAM360 VR technology stands out for its ability to provide first-person and 360-degree views for both training and broadcast purposes. However, there are competitors, such as iTrackHockey and IcePerk, offering adjacent solutions, though they lack the VR angle. While Proposing Company has applied for patents, none have been granted yet, meaning the moat is largely dependent on the approval and enforcement of these patents.
Red Flag: Patent protection is still pending, and the market includes other players providing similar solutions, potentially eroding Proposing Company’s competitive edge.
Upside: If the patent is granted and Proposing Company continues to innovate in integrating VR into broadcasting and training, it could maintain a competitive edge.

3. Deal and Deal Structure: 6.5
Analysis: Proposing Company is offering a $1.75M convertible note with a pre-money valuation of $2M, which is reasonable for a seed-stage company with novel technology. The valuation appears appropriate given their early stage and the potential of their technology. The company aims for a 5x to 10x exit based on their forecast, contingent on expanding their technology into additional sports and markets.
Red Flag: The company has yet to secure major clients or revenue, so returns will depend on future fundraising and hitting key milestones.
Upside: If Proposing Company can secure partnerships with major sports leagues or broadcasting companies, the deal could become more attractive to early investors.

4. Team (Heavily Weighted): 9
Analysis: The leadership team, led by Keith Blase, includes experienced individuals from the sports and broadcasting industries. The addition of Mike Sullivan, an NHL coach, further strengthens the team’s expertise in professional sports. The team has worked together on multiple ventures and brings deep knowledge of both the sports training and media landscapes. This experience and network are crucial for market penetration.
Red Flag: No significant red flags regarding the team’s qualifications, though scaling a tech-heavy business model in the competitive VR market remains challenging.
Upside: The leadership's extensive experience in sports management and broadcasting provides the company with significant industry leverage, especially in securing partnerships.

5. Marketing and Sales Plans: 5.5
Analysis: Proposing Company has yet to fully develop a comprehensive marketing and sales strategy, although they plan to target professional sports teams and collegiate leagues. Early-stage marketing remains speculative, and the company has not yet demonstrated significant traction in signing contracts or partnerships. The leadership’s connections in the sports industry offer potential pathways for future deals.
Red Flag: The lack of concrete marketing plans and signed partnerships at this stage may slow down revenue generation.
Upside: Strong industry relationships and high-profile advisors may help fast-track partnerships with key players in sports broadcasting and training.

6. Financials: 4.5
Analysis: Proposing Company is currently pre-revenue, and the pitch deck does not include immediate revenue generation. The company has a significant runway ahead and will need further funding to support operations. While their financial projections are optimistic, they depend heavily on securing contracts with major sports organizations.
Red Flag: No current revenue and the need for further funding rounds create financial risk for early investors.
Upside: If the company secures early partnerships and enters new markets, it can mitigate this risk by establishing a more solid revenue stream.

7. Exit Potential: 7
Analysis: Proposing Company’s exit potential includes licensing deals or being acquired by larger broadcasting or sports tech companies. The growth in the immersive sports experience market makes them an attractive acquisition target if they can show significant traction. The company also has potential for an IPO if they expand into additional sports or entertainment markets.
Red Flag: Exit potential depends heavily on market traction and successful product adoption, which could take longer than anticipated.
Upside: A strong partnership with a broadcasting giant or professional league could accelerate the exit timeline.

Total Weighted Score: 7.2/10

High-Risk Areas (RED FLAGS):
Pre-revenue status: The company remains pre-revenue, with no signed contracts, making financial projections highly speculative.
Patent uncertainty: With the patent still pending, competitors could potentially develop similar solutions, reducing Proposing Company’s market advantage.
Niche market focus: Focusing only on hockey may limit growth unless the company expands quickly into other sports or sectors.

Upside Potential:
Innovative technology: The ability to provide immersive VR experiences in sports training and broadcasting is an exciting prospect, particularly as fan engagement technologies continue to grow.
Strong leadership: The team’s extensive experience in sports management and broadcasting provides significant potential for securing strategic partnerships and scaling quickly.
Expanding market: The global market for immersive sports experiences, including VR training and broadcast engagement, is expanding rapidly, providing ample opportunities for Proposing Company to grow.

Conclusion:
Proposing Company VR has significant potential in the sports tech and fan engagement markets, but faces challenges around securing initial clients and proving its product’s traction in the market. While the team is a strong asset, the company’s current pre-revenue status and patent uncertainty present notable risks. With a total score of 7.2/10, Proposing Company shows promise but needs to overcome several hurdles before it becomes an attractive investment for larger-scale angel investors.



--- FILE: investorkb/Investment_Summary_Proposing_Company_v3.txt ---

Investment Summary and Preliminary Due Diligence: Proposing Company

Executive Summary (Updated with Financial Analysis)
Elevator Pitch
Proposing Company, a Boston-based medtech startup, introduces an advanced electrocautery device integrating four key functionalities—electrocautery, on-demand suction, smoke evacuation, and blunt dissection—into a single-use, low-profile tool. This device aims to optimize surgical efficiency and reduce the need for multiple instruments in the operating room, addressing key challenges that surgeons face with existing devices.
Differentiation and Financial Feasibility
ClearCut's integrated device design differentiates it in a highly competitive electrosurgery market. The financial projections indicate a 7-year path to profitability with revenue growth dependent on adoption by major healthcare institutions. Projections seem reasonable given the need for streamlined surgeries and increased regulatory mandates on smoke evacuation. However, ClearCut’s reliance on disposables, high COGS at launch, and potential market resistance among cost-sensitive institutions may affect long-term acceptance and profitability.

Detailed Analysis (Updated)
1. Leadership of the Company
Evaluation: With expertise in clinical practice and medical device commercialization, ClearCut’s leadership team is well-positioned for initial product development and regulatory navigation. CEO Jeff Caputo’s extensive experience supports the strategic commercialization of a medtech product.
Strengths: Strong foundational leadership with backgrounds in clinical surgery and device manufacturing, although limited distribution experience may necessitate additional advisory resources.
Concerns: Scaling into full commercialization may require recruiting team members with large-scale distribution expertise.
Score: 8.5/10
2. Market Assessment and Product-Market Fit
Market Size: The global electrocautery device market is valued at $7.5 billion, driven by the prevalence of electrocautery in surgery. ClearCut’s estimated SOM is $500 million within the U.S., targeting 10 million surgeries annually【9†source】.
Revenue Growth Potential: The forecasted revenue growth, starting from $250,000 in 2026 and increasing to $16.26 million by 2030, aligns with adoption targets in major healthcare systems, given regulatory and market demands for improved smoke evacuation and multi-functional surgical tools【18†source】.
Concerns: Market acceptance among cost-sensitive institutions could pose a challenge due to ClearCut’s disposable model, which might not yield immediate operational cost savings.
Score: 8/10
3. Competition and Differentiation
Competitive Edge: ClearCut’s device consolidates multiple functions (smoke evacuation, suction, and blunt dissection) not available in competitive devices, enhancing procedural efficiency and visibility during surgery.
Device Acceptance: Initial surgeon feedback indicates preference for ClearCut’s retractable suction functionality, addressing a key pain point with existing smoke evacuation devices【8†source】. However, higher COGS during the early years may challenge its acceptance, particularly in cost-sensitive healthcare settings.
Competitive Comparison: Competitors like Stryker and Medtronic do not offer all-in-one solutions and lack ergonomic retractability in their devices, providing ClearCut a strategic advantage【9†source】.
Score: 8.5/10
4. Technology/IP/Roadmap
Development Stage: ClearCut aims for FDA submission by 2025 with an issued patent that offers robust IP protection for its unique functionality【7†source】.
Strengths: Strong IP foundation and an FDA clearance path, enhancing its defensibility and attractiveness as an acquisition target.
Concerns: Delays in FDA approval could impact market entry timelines and revenue projections.
Score: 8/10
5. Unique Differentiators
Strategic Control Points: ClearCut’s differentiation lies in its combined functionalities, addressing both the ergonomic and procedural inefficiencies of current devices. The device’s retractable suction tube provides unobstructed views, a critical differentiator.
Sustainability: Increased regulatory focus on smoke evacuation bolsters ClearCut’s long-term viability, though adoption incentives may be necessary to drive market penetration.
Score: 8.5/10
6. Business Model and Financials (Updated)
Revenue Model: A disposable, single-use model with anticipated gross margins improving from 50% initially to 90% by 2030. Pricing is aligned to fit within smoke evacuation budgets, with anticipated ASP growth from $35 to $45【18†source】.
Financial Projections (Chart Included):
Strengths: Projections are conservative yet achievable, assuming successful adoption among major U.S. hospitals and partnerships with distributors to reduce COGS.
Concerns: High operating expenses initially, with cumulative cash flow negative until 2028, indicating the need for continuous funding rounds. Additionally, reliance on disposables may face resistance from hospital budget managers unless efficiency gains justify the cost.
Score: 6.5/10
7. Traction
Current Traction: Although ClearCut has positive surgeon feedback from preclinical tests, revenue generation is set to start only in 2026, with significant adoption projected by 2028.
Concerns: Lack of active customer base and revenue during the early years raises uncertainty regarding achieving the projected revenue milestones.
Score: 6.5/10
8. Go-to-Market Strategy
Target Market: Focused on orthopedic and general surgery in major academic hospitals and ambulatory centers.
Strategy and Partnerships: Distribution through partners like Medline and strategic collaborations with smoke evacuation leaders, such as Stryker, are anticipated to drive adoption【8†source】.
Concerns: Reliance on distributor partnerships could delay market penetration if strategic partners prioritize their in-house solutions.
Score: 7/10
9. Deal Terms and Valuation
Funding Needs: Projected total funding needs range from $3.5M–$4M initially, with subsequent rounds of $5M in Series A funding to support FDA clearance and market entry by 2027.
Valuation Comparison: ClearCut’s funding needs align with typical early-stage medtech development costs, though valuation sensitivity may increase if FDA timelines extend.
Score: 7/10
10. Exit Plan
Exit Opportunities: Potential acquisition targets include large device manufacturers like Medtronic or Stryker, who have an established interest in smoke evacuation and surgical tools.
Realistic Nature: Likely exit if ClearCut achieves FDA approval and initial market traction, making it an appealing addition to a larger medical device portfolio.
Score: 7.5/10
11. Risks and Mitigation Strategies (Expanded)
Doctor Acceptance and Cost Sensitivity: Physicians and hospitals may be cautious of the device’s disposable nature. To mitigate this, ClearCut can:
Implement educational programs to showcase procedural efficiency and potential reductions in OR time.
Partner with academic centers to conduct clinical studies validating cost benefits and efficiency gains.
Offer promotional pricing or free trials to incentivize early adoption in prominent institutions.
Regulatory and Financial Risks: Extended FDA review periods and high OPEX projections pose financial strain. Mitigation includes incremental funding based on achievable milestones and outsourcing non-core activities to manage costs.
Overall Risk Rating: Medium-high due to the combination of regulatory and market adoption challenges.
Score: 6.5/10

Scoring Summary (Updated with Financials)
Average Weighted Score: 7.3/10
Unweighted Score: 7.2/10

Conclusion
Proposing Company’s product innovation and strategic targeting position it well in a growing market. The financial projections align reasonably with revenue milestones contingent on adoption by hospitals and institutions. Strategies to enhance physician acceptance and cost-efficiency could improve market traction and secure a favorable acquisition exit. However, regulatory and financial challenges remain significant.
Recommendation: Proceed with investment consideration, emphasizing adoption incentives and hospital partnerships to improve early-stage financials and validate cost-effectiveness in real-world settings.



--- FILE: investorkb/Comprehensive_Due_Diligence_Proposing_Company_v1.txt ---

Comprehensive Due Diligence Review of Proposing Company

1. Company Overview and Elevator Pitch
Elevator Pitch
Proposing Company positions itself as the “Home Brain,” leveraging its Single Interface Dashboard (SID) to unify AI and IoT applications across smart home, security, healthcare, and business automation. The platform combines large language models (LLMs) and computer vision, allowing developers to create customized AI applications through an AI App Store similar to Apple’s App Store. Proposing Company's edge computing approach minimizes cloud reliance, offering faster response times and lower costs​(Proposing Company_Pitch_Deck_v24).

2. Executive Summary
Summary Table of Scores
Total Static Score: 68/110
Total Weighted Score: 85.25/140
Weighted Average Score: 6.4/10

3. Leadership of the Company
Leadership Overview
CEO: Khurram Hussain has a history of founding companies, including Mojo Solutions. However, some prior ventures, such as AvaBot, were less successful​(Proposing Company_Pitch_Deck_v24).
CTO: Ali Raza has over 20 years of experience in software development for consumer, SaaS, and cloud services​(Proposing Company_Pitch_Deck_v24).
Advisors: Includes Tony Lhander, specializing in investor relations, and Malick Noor, who has extensive experience in technology sales​(Proposing Company_Pitch_Deck_v24).
Concerns: While technically strong, the team lacks a proven record of scaling hardware products, increasing execution risk.
Leadership Evaluation
Score: 7/10
Weight: 2.0
Weighted Score: 14

4. Market Assessment and Product Market Fit
Market Overview
Market Problem: Traditional smart systems lack contextual intelligence, requiring multiple interfaces and heavy cloud dependence​(Proposing Company_Pitch_Deck_v24).
Solution and TAM: Proposing Company’s platform integrates LLMs and CV for a single-interface smart home solution. The total addressable market for smart homes and related IoT applications is estimated at $150B​(Proposing Company_Pitch_Deck_v24).
Concerns: Reliance on the smart doorbell limits early adoption; broadening the product suite will be necessary to address this vast market fully.
Market Fit Evaluation
Score: 7/10
Weight: 2.0
Weighted Score: 14

5. Competition
Competitive Landscape
Direct Competitors: Ring (Amazon), Nest (Google), and traditional security providers dominate the market​(Proposing Company_Pitch_Deck_v24).
Competitive Edge: Proposing Company offers edge computing and an AI marketplace, providing a potential edge over cloud-dependent competitors.
Concerns: The competitive moat is weak, as competitors have significant brand loyalty, resources, and similar capabilities.
Competition Evaluation
Score: 6/10
Weight: 1.5
Weighted Score: 9

6. Technology/IP/Roadmap
Technology Overview
Core Technology: Combines AI-driven LLM and computer vision for edge processing. Proposing Company claims to be the first to introduce an AI App Store for computer vision models​(Proposing Company_Pitch_Deck_v24).
Patents: The company holds 24 filed patents, covering edge computing, computer vision, and AI-driven IoT applications​(Proposing Company_Pitch_Deck_v24).
Product Roadmap: Hardware production and marketing efforts are set to scale in 2024, with the AI marketplace opening to developers by Q1 2025​(Proposing Company_Pitch_Deck_v24).
Technology/IP Evaluation
Score: 7/10
Weight: 1.5
Weighted Score: 10.5

7. Unique Differentiators
Differentiators Overview
Core Unique Selling Points: Customizable AI marketplace, edge computing technology, and a single-interface dashboard​(Proposing Company_Pitch_Deck_v24).
Concerns: The company’s reliance on developer-driven differentiation is a potential risk if the marketplace fails to attract robust participation.
Differentiators Evaluation
Score: 6.5/10
Weight: 1.0
Weighted Score: 6.5

8. Business Model and Financials
Business Model Overview
Revenue Streams: Hardware sales, AI marketplace subscriptions, and custom B2B solutions​(Proposing Company_Pitch_Deck_v24).
Financial Projections: Aggressive projections of $67M by 2028, with SaaS revenues outpacing hardware sales​(Proposing Company_Pitch_Deck_v24).
Concerns: The reliance on high subscription adoption rates presents financial risks. The model is ambitious and unproven.
Business Model Evaluation
Score: 6/10
Weight: 1.0
Weighted Score: 6

9. Traction
Traction Overview
Pre-Orders: 200 pre-orders and a 500-unit LOI from a wholesaler indicate initial interest​(Proposing Company_Pitch_Deck_v24).
Concerns: Minimal customer validation, limited pre-sales, and no large-scale partnerships are red flags.
Traction Evaluation
Score: 5/10
Weight: 1.0
Weighted Score: 5

10. Go-to-Market Strategy
GTM Strategy Overview
Channels: Direct-to-consumer and B2B, with initial focus on pre-orders and LOIs​(Proposing Company_Pitch_Deck_v24).
Marketing Plan: Includes Amazon sales and a B2B rollout by 2025​(Proposing Company_Pitch_Deck_v24).
Concerns: The GTM strategy lacks a clear differentiation in a competitive market and may struggle against better-known brands.
GTM Strategy Evaluation
Score: 6.5/10
Weight: 1.0
Weighted Score: 6.5

11. Deal Terms and Valuation
Deal Terms Overview
Valuation: $10M with a $2M SAFE raise at a 20% discount​(Proposing Company_Pitch_Deck_v24).
Concerns: This valuation seems high for a company with limited traction, making it challenging for investors to justify given the current risk level.
Deal Terms Evaluation
Score: 5.5/10
Weight: 1.0
Weighted Score: 5.5

12. Exit Plan
Exit Strategy Overview
Potential Acquirers: Likely exits include acquisition by Amazon, Google, or security/IoT companies seeking AI and IoT capabilities​(Proposing Company_Pitch_Deck_v24).
Concerns: Proposing Company will need traction and product differentiation to become an attractive acquisition target. Execution on the platform and developer engagement are key.
Exit Plan Evaluation
Score: 6.5/10
Weight: 0.5
Weighted Score: 3.25

13. Risks and Impact
Risks Overview
Key Risks:
Execution: Limited hardware experience on the team and an ambitious roadmap.
Financial: Heavy reliance on high subscription adoption to meet projections.
Market: High competition with major players dominating the smart home space.
Mitigation: Strategic partnerships and a strong focus on customer and developer acquisition are essential.
Risks and Impact Evaluation
Score: 6/10
Weight: 1.0
Weighted Score: 6

Conclusion and Recommendations
Final Scores
Total Static Score: 68/110
Total Weighted Score: 85.25/140
Weighted Average Score: 6.4/10
Conclusion:
Proposing Company brings a promising concept with an AI-driven IoT platform that combines LLMs and computer vision in a single interface, catering to a variety of smart home, security, and automation needs. However, it faces several challenges:
Limited Traction: The company has achieved only minimal pre-orders and lacks significant partnerships, which are essential to establish initial market presence and build customer trust.
High Competition: With established players like Amazon (Ring) and Google (Nest) already dominating the smart home and security sectors, Proposing Company will need a strong differentiator to stand out.
Aggressive Financial Projections: The revenue goals, particularly for the AI marketplace subscriptions, are ambitious and carry a high level of risk. Achieving these projections requires rapid adoption, which remains unproven.
While the technology holds promise, Proposing Company’s success will heavily depend on its ability to execute on the product roadmap, attract a robust developer ecosystem, and build partnerships to secure its position in the market.
Red Flags:
Limited traction and minimal partnerships to date.
High reliance on a niche product (smart doorbell) as the primary entry to market.
Ambitious financial projections that are heavily dependent on unproven subscription adoption.
Upside Potential:
If successful, Proposing Company’s AI marketplace could position it as a major player in the smart home and broader IoT sectors. By building a developer-driven ecosystem, the platform could diversify into various applications beyond security, potentially becoming a comprehensive smart home and automation hub.
Recommendation:
Proceed with caution. Given Proposing Company’s early stage and substantial execution risks, investors should seek a lower valuation or more favorable deal terms, such as a higher discount on the SAFE note. The potential exists for substantial returns if Proposing Company can establish a robust user base and achieve traction, but this remains speculative given current market conditions and competitive pressures.



--- FILE: investorkb/CompanyC_Proposing_Company_Analysis_v2.txt ---


Here’s a comprehensive analysis of Proposing Company based on the provided pitch deck, general market research on concussion detection and analysis, and the competitive landscape.
Executive Summary
Proposing Company has developed a patented, rapid, and non-invasive saliva-based test to detect concussions, aiming to make concussion diagnosis accessible in sports, military, and emergency scenarios. Their technology is positioned as the first saliva-based concussion test, providing near-instant results and reducing reliance on existing, slower blood-based diagnostic methods. Proposing Company leverages a mobile app for patient tracking, which further strengthens their offering by enabling long-term concussion management.
Overall Recommendation: Move to screen for further due diligence, given the strong market demand, uniqueness, and unmet need in concussion diagnostics.

1. Leadership of the Company
Proposing Company’s leadership team should ideally have a blend of expertise in both medical technology and sports health to navigate clinical trials, regulatory requirements, and commercialization in healthcare.
Score: 7.5/10
Weighted Score: 15/20
Notes: For further due diligence, review the depth of the team’s expertise in scaling health technology and their connections within the sports and military sectors.

2. Market Assessment and Product-Market Fit
Market Size: The global concussion diagnostics market, especially in sports and military contexts, is expanding with a projected compound annual growth rate (CAGR) of 6.5% until 2030. In the U.S. alone, over 4 million concussions are reported annually from sports injuries​.
Product-Market Fit: Proposing Company addresses the limitations of existing diagnostics, which often involve delayed, indirect, or invasive blood tests and costly neuroimaging. Their saliva-based test is uniquely positioned for environments where time-sensitive and accessible testing is critical, such as sports fields and battlefields.
Score: 8/10
Weighted Score: 16/20
Notes: Further analysis of pricing strategy and partnerships, especially with athletic organizations and military entities, is needed to validate market penetration.

3. Competition
Direct Competitors: Existing concussion diagnostics rely on blood-based tests (e.g., Banyan Biomarkers) or neuroimaging technologies (e.g., CT/MRI). These are slower and often impractical in-field, providing Proposing Company a potential competitive edge as the only saliva-based test.
Indirect Competitors: Applications or services that perform symptom-based assessments or digital cognitive tests may be considered indirect competitors, as they offer alternatives to initial diagnostics.
Score: 7/10
Weighted Score: 10.5/15
Notes: Conan’s technology’s value proposition will be strengthened if patents hold against possible competitors developing similar biomarker-based saliva tests. Monitoring competitive developments in related diagnostics is recommended​​.

4. Technology, Patents, and Moat
Technology: Proposing Company’s platform includes a rapid, field-deployable diagnostic device paired with a mobile app for longitudinal tracking, designed to work outside traditional healthcare settings.
Patents: The pitch deck claims patent protection, which establishes a barrier to entry but requires validation against NIH and patent databases to confirm exclusivity in biomarker selection and saliva-based processing​​.
Score: 8/10
Weighted Score: 12/15
Notes: Confirm the breadth and enforceability of patents to assess protection strength fully. Additional patents in software for tracking could strengthen their moat.

5. Deal Terms and Valuation
To accurately assess deal terms, more clarity on Proposing Company’s pre-money valuation, cap, and terms (e.g., SAFE note, equity) is required.
Score: 6/10
Weighted Score: 6/10
Notes: Early-stage valuation relative to future revenue projections would require a realistic assessment, factoring in fundraising needs to reach breakeven and achieve a 10x exit potential.

6. Financial Projections
Revenue Growth Potential: Revenue is likely to stem initially from direct sales in high-need markets, with subsequent partnerships for larger-scale rollouts. Given the healthcare segment, particularly in sports and military, a cautious growth model with steady market adoption over 5-10 years is likely.
Score: 7/10
Weighted Score: 7/10
Notes: Long-term revenue projections will depend on the ability to secure partnerships and reach volume contracts, particularly with sports and healthcare providers​​.

7. Go-to-Market Strategy
Strategy: Proposing Company has a clear B2B strategy for sports leagues, military applications, and medical centers. Their mobile application also provides an added avenue for patient engagement and monitoring.
Score: 8/10
Weighted Score: 8/10
Notes: Focus on partnerships with influential sports and military institutions could accelerate market adoption. Monitoring the commercialization strategy and pilot programs would be beneficial.

8. Exit Potential
The exit potential for Proposing Company lies in acquisition by a major diagnostic, healthcare, or sports tech company, particularly as concussion awareness and diagnostics are increasingly prioritized.
Score: 7/10
Weighted Score: 3.5/5
Notes: Early conversations with potential acquirers or partnerships could validate this pathway. Establishing a clear acquisition target list would enhance the exit plan's strength.

9. Risk Assessment
Key Risks:
Regulatory Approval: Securing FDA clearance or equivalent is crucial. Early-stage healthcare devices face potential regulatory delays.
Competitive Response: Larger diagnostics players may attempt to enter the saliva-based market, and potential regulatory or IP challenges could arise.
Execution on Partnerships: Conan’s heavy reliance on securing partnerships poses a risk if these are delayed or fail to materialize.
Score: 6.5/10
Weighted Score: 6.5/10
Notes: Identifying potential backup markets or partners could mitigate these risks.

Scoring Summary and Conclusion
Total Weighted Score: 84.5/110
Unweighted Average: 7.25/10
Weighted average ;   7.7

Recommendation
Move to Prescreen: Proposing Company shows promise in an expanding market with minimal direct competition in saliva-based diagnostics. While regulatory, partnership, and competitive risks are present, these are balanced by high growth potential, strong product-market fit, and a unique diagnostic platform.



--- FILE: tests/test-services.py ---

import unittest
from unittest.mock import patch
from investment_analysis.services import InvestmentAnalysisService
import pytest

class TestInvestmentAnalysisService(unittest.TestCase):

    @patch('investment_analysis.services.openai.Client')  # Mock the OpenAI client
    def test_analyze_investment_success(self, mock_openai_client):
        # Configure the mock to return a specific response
        mock_response = type('obj', (object,), {'choices': [type('obj', (object,), {'message': type('obj', (object,), {'content': 'Mock analysis'})})]})
        mock_openai_client.return_value.chat.completions.create.return_value = mock_response

        service = InvestmentAnalysisService(openai_api_key="dummy_key")
        result = service.analyze_investment("Test input")
        self.assertEqual(result, "Mock analysis")

    @patch('investment_analysis.services.openai.Client')
    def test_analyze_investment_api_error(self, mock_openai_client):
        # Configure the mock to raise an exception
        mock_openai_client.return_value.chat.completions.create.side_effect = Exception("API error")

        service = InvestmentAnalysisService(openai_api_key="dummy_key")
        with self.assertRaises(ValueError) as context:
            service.analyze_investment("Test input")
        self.assertTrue("API error" in str(context.exception))


--- FILE: investment_analysis/services.py ---

import openai
import logging
import os

class InvestmentAnalysisService:
    def __init__(self, openai_api_key=None):
        self.openai_api_key = openai_api_key or os.environ.get("OPENAI_API_KEY")
        if not self.openai_api_key:
            raise ValueError("OpenAI API key is required. Set OPENAI_API_KEY environment variable or pass it to the constructor.")
        self.client = openai.Client(api_key=self.openai_api_key)
        self.system_prompt = "You are an expert on startup investment analysis."

    def analyze_investment(self, user_input):
        try:
            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": user_input}
                ]
            )
            return response.choices[0].message.content.strip()
        except openai.APIConnectionError as e:
            logging.error(f"API Connection Error: {e}")
            raise ValueError("Could not connect to the OpenAI API. Please check your internet connection.") from e
        except openai.RateLimitError as e:
            logging.error(f"Rate Limit Error: {e}")
            raise ValueError("OpenAI API rate limit exceeded. Please try again later.") from e
        except Exception as e:
            logging.error(f"OpenAI API call failed: {str(e)}")
            raise ValueError(f"OpenAI API call failed: {str(e)}") from e


--- FILE: investment_analysis/utils.py ---

def format_response(response_text):
    """
    Format API response for readability in the web UI.
    - Uses numbered sections (1., 2., 3.).
    - Each section has a subtitle, then a line break, then the content.
    """
    formatted_text = response_text.replace("**", "").replace("\n", "<br><br>")
    formatted_text = formatted_text.replace("1. ", "<strong>1. </strong>")
    formatted_text = formatted_text.replace("2. ", "<strong>2. </strong>")
    formatted_text = formatted_text.replace("3. ", "<strong>3. </strong>")
    formatted_text = formatted_text.replace("4. ", "<strong>4. </strong>")
    formatted_text = formatted_text.replace("5. ", "<strong>5. </strong>")

    return f"<strong>Analysis Report:</strong><br>{formatted_text}"

def format_pdf_content(summary_data):
    """
    Format content for structured PDF output.
    - Uses numbered sections (1., 2., 3.).
    - Ensures section numbers are followed by subtitles and content.
    - Sections are spaced out for readability.
    """
    formatted_text = summary_data.replace("**", "")
    formatted_text = formatted_text.replace("\n\n", "<br><br>")
    formatted_text = formatted_text.replace("1. ", "<div class='section'><span class='section-number'>1.</span> <span class='subtitle'>Introduction</span><br><div class='content'>")
    formatted_text = formatted_text.replace("2. ", "</div><div class='section'><span class='section-number'>2.</span> <span class='subtitle'>Market Analysis</span><br><div class='content'>")
    formatted_text = formatted_text.replace("3. ", "</div><div class='section'><span class='section-number'>3.</span> <span class='subtitle'>Financial Overview</span><br><div class='content'>")
    formatted_text = formatted_text.replace("4. ", "</div><div class='section'><span class='section-number'>4.</span> <span class='subtitle'>Competitive Landscape</span><br><div class='content'>")
    formatted_text = formatted_text.replace("5. ", "</div><div class='section'><span class='section-number'>5.</span> <span class='subtitle'>Conclusion</span><br><div class='content'>")

    return formatted_text + "</div>"


--- FILE: word_counter/__init__.py ---



--- FILE: word_counter/word_counter.py ---

from flask import Blueprint, render_template, request, session
import re
from collections import Counter
import logging
from flask_wtf import FlaskForm
from wtforms import FileField, SubmitField
from wtforms.validators import InputRequired

wc_bp = Blueprint('wc', __name__, template_folder='templates')  # Corrected name

class UploadFileForm(FlaskForm):
    file_upload = FileField('File', validators=[InputRequired()])
    submit = SubmitField('Upload File')

@wc_bp.route('/word_counter', methods=['GET', 'POST'])
def word_counter():
    form = UploadFileForm()
    word_counts = None

    if form.validate_on_submit():
        try:
            file = form.file_upload.data
            text = file.read().decode('utf-8')

            # Clean and split the text into words:  Lowercase and split by spaces and punctuation
            words = re.findall(r'\b\w+\b', text.lower())

            # Count the words using Counter
            word_counts = Counter(words)
            # word_counts = Counter(words)
            sorted_word_counts = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)  # Sort by count in descending order
            #session['word_counts'] = sorted_word_counts  #Store words in session
            session['word_counts'] = sorted_word_counts #Use sorted session.

        except Exception as e:
            logging.error(f"Error processing file: {e}")
            return render_template('word_counter.html', form=form, error=str(e))

    return render_template('word_counter.html', form=form, word_counts=session.get('word_counts', None)) #Passes in the variable.


--- FILE: word_counter/templates/word_counter.html ---

<!DOCTYPE html>
<html>
<head>
    <title>Word Counter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1E2A38;
            color: #E5E5E5;
            padding: 20px;
            text-align: center;
        }

        .container {
            max-width: 800px;
            padding: 20px;
            background: #2A3D55;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            margin: 20px auto;
        }

        h1 {
            color: #2D9CDB;
        }

        .word-count {
            text-align: left;
        }

        .word-count ul {
            list-style-type: none;
            padding: 0;
        }

        .word-count li {
            padding: 5px 0;
            border-bottom: 1px solid #4C657E;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #D9E1EC;
        }

        input[type="file"] {
            background-color: #3d597a;
            color: #D9E1EC;
            padding: 10px;
            border-radius: 6px;
            border: none;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #27AE60;
            color: white;
            border: none;
            border-radius: 6px;
        }

        .error {
            color: red;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Word Counter</h1>

        <form method="POST" enctype="multipart/form-data">
            {{ form.csrf_token }}  <!-- HERE:  Print the field in the form-->
            <label for="file_upload">Upload a text file:</label>
            {{ form.file_upload }}
            {{ form.submit() }}
        </form>

        {% if error %}
            <p class="error">Error: {{ error }}</p>
        {% endif %}

        {% if word_counts %}
            <canvas id="wordChart" width="400" height="200"></canvas>

            <div class="word-count">
                <h2>Word Counts:</h2>
                <ul>
                    {% for word, count in word_counts %}
                        <li>{{ word }}: {{ count }}</li>
                    {% endfor %}
                </ul>
            </div>
            <script>
                const ctx = document.getElementById('wordChart').getContext('2d');
                const wordCounts = {{ word_counts|tojson }};

                const labels = wordCounts.map(item => item[0]);
                const data = wordCounts.map(item => item[1]);

                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Word Count',
                            data: data,
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            </script>
        {% endif %}
    </div>
</body>
</html>

--- FILE: walt/bio_creator_prompt.txt ---

# walt/bio_creator_prompt.txt
# walt/bio_creator_prompt.txt
# Improved bio_creator_prompt.txt (Improvement #4: Tone Adjustment)
Take the following input and write a brilliant and **{{biography_tone}}** biography of the person.
Do not fill in chapters that have insufficient information to draft. Simply include the chapter in the outline and mark it as "TBD".
You may rework other chapters already written if the newest conversation improves them.
After the biography, include a master list of all facts accumulated so far about the person.


--- FILE: walt/walt.py ---

# file: walt/walt.py
from flask import Blueprint, render_template, request, jsonify, session
import os
import openai
import logging
import json
from werkzeug.utils import secure_filename

walt_bp = Blueprint('walt', __name__, template_folder='templates')

@walt_bp.route('/')  # CORRECT: Route is root '/' within the walt_bp blueprint
def walt_window():
    new_bio = request.args.get('new_bio') # Check for new_bio parameter

    if 'conversation' not in session or new_bio == 'true': # Check for session OR new_bio parameter
        if 'conversation' in session: # Clear old session if starting new bio
            session.pop('conversation', None)
            session.pop('biography_outline', None)
            session.pop('file_content', None)

        # Render splash screen if no session OR new bio requested
        return render_template('walt_splash.html') # CORRECT: Template in walt/templates
    else:
        # Existing session (returning user) - proceed to main app
        return render_template('walt_window.html', biography_outline=session['biography_outline'], initial_message=None) # CORRECT: Template in walt/templates


@walt_bp.route('/get_walt_prompt')
def get_walt_prompt():
    try:
        with open('walt_prompt.txt', 'r', encoding='utf-8') as f:
            prompt_text = f.read()
        return prompt_text
    except FileNotFoundError as e:
        logging.error(f"Error reading walt_prompt.txt: {str(e)}")
        return jsonify({"error": "walt_prompt.txt not found!"}), 404
    except Exception as e:
        logging.error(f"General error in get_walt_prompt: {str(e)}")
        return jsonify({"error": f"Error reading walt_prompt.txt: {str(e)}"}), 500

@walt_bp.route('/walt_analyze', methods=['POST'])
def walt_analyze():
    user_input = request.form.get('user_query')
    uploaded_content = request.form.get('uploaded_content', '')
    desired_tone = request.form.get('tone', 'default')  # Get tone from request

    if not user_input: # Corrected line - using user_input
        return jsonify({"error": "No user query provided"}), 400

    try:
        with open('walt_prompt.txt', 'r', encoding='utf-8') as f:
            walt_prompt_base = f.read()

        # Incorporate tone into prompt (Improvement #4)
        if desired_tone != 'default':
            walt_prompt = walt_prompt_base + f"\nThe user prefers a biography with a {desired_tone} tone."
        else:
            walt_prompt = walt_prompt_base


    except FileNotFoundError:
        return jsonify({"error": "walt_prompt.txt not found!"}), 500
    except Exception as e:
        return jsonify({"error": f"Error reading walt_prompt.txt: {str(e)}"}), 500

    if 'conversation' not in session:
        initial_greeting = "Hi I'm Walt. What's your name?"
        session['conversation'] = [{"role": "system", "content": walt_prompt},
                                     {"role": "assistant", "content": initial_greeting}]
        session['biography_outline'] = get_biography_outline()  # Initialize outline in session (Improvement #5)


    if uploaded_content:
        session['conversation'].append({"role": "system", "content": f"Here is context from your biography: {uploaded_content}"})
        print(f"UPLOADED CONTENT TO OPEN API:{uploaded_content}")
    else:
        print("NO UPLOADED CONTENT!")

    # Improvement #2: Dynamic Chapter Suggestion - Removed fixed chapter selection in prompt
    session['conversation'].append({"role": "user", "content": user_input + ".  Continue to help me build my biography."})


    try:
        client = openai.Client()
        logging.info(f"OpenAI Request Messages: {session['conversation']}")

        # --- FIRST OPENAI CALL: Get Walt's normal response ---
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=session['conversation'],
            temperature=0.7,
            max_tokens=256,
            top_p=1
        )
        api_response = response.choices[0].message.content.strip()

        # --- SECOND OPENAI CALL: Get Walt's Fact-Check Question (Improved version) ---
        verification_prompt_text = f"From our last exchange: '{user_input}' and Walt's response: '{api_response}', suggest 1-2 very natural, brief follow-up questions Walt might ask to clarify details or get more specific information about what the person just said.  Think of questions a friendly biographer would ask in a casual conversation, like 'Where did that happen?' or 'What year was that?' Keep the tone friendly and natural, like Walt."  # More natural tone in fact-check prompt
        verification_prompt = [{"role": "system", "content": "You are Walt, a friendly biographer focused on getting accurate details. Your goal is to ask natural, short follow-up questions - think 'where', 'when', 'who' - to clarify the user's story."},  # Improved system prompt for natural questions
                              {"role": "user", "content": verification_prompt_text}]  # Define prompt as list of dicts

        verification_response = client.chat.completions.create(
            model="gpt-4o",
            messages=verification_prompt,  # Use the defined verification_prompt
            temperature=0.5,  # Lower temp for fact-checking
            max_tokens=100  # Reduced max tokens for brevity
        )
        verification_message = verification_response.choices[0].message.content.strip()
        api_response_with_verification = api_response + "\n\n" + verification_message


        session['conversation'].append({"role": "assistant", "content": api_response_with_verification})  # Use combined response
        session.modified = True

        return jsonify({"response": api_response_with_verification, "biography_outline": session['biography_outline']})  # Include outline in response

    except Exception as e:
        logging.error(f"OpenAI API Error: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@walt_bp.route('/walt_session_summary', methods=['POST'])
def walt_session_summary():
    session_content = ""
    try:
        client = openai.Client()
        session_info = session.get('conversation', [])
        session_content = ""
        if 'file_content' in session:
            file_content = session['file_content']
        else:
            file_content = "No story started"

        session_content = session_info if session_info else "No story started"

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "system", "content": "Your job is to deliver the status and summary of the session, the outline of sections written, the conversation history and the prompt.  Do not add anything else."},
                      {"role": "user", "content": f"Return all known story with with outline, sections written, session prompts, system_info and the conversation for {session_content}."}],
            temperature=0.7,
            max_tokens=2000,
            top_p=1
        )
        api_response = response.choices[0].message.content.strip()

    except Exception as e:
        print(f"Error calling OpenAI: {e}")
        return jsonify({"error": str(e)}), 500

@walt_bp.route('/load_checkpoint', methods=['POST'])
def load_checkpoint():
    checkpoint_data = request.form.get('checkpoint_data')
    if not checkpoint_data:
        return jsonify({"error": "No checkpoint data received"}), 400

    try:
        # Load the Walt Prompt (still needed)
        try:
            with open('walt_prompt.txt', 'r', encoding='utf-8') as f:
                walt_prompt = f.read()
        except FileNotFoundError as e:
            logging.error(f"Error reading walt_prompt.txt: {str(e)}")
            return jsonify({"error": f"Error reading walt_prompt.txt: {str(e)}"}), 500
        except Exception as e:
            logging.error(f"General error in get_walt_prompt: {str(e)}")
            return jsonify({"error": str(e)}), 500

        # Split checkpoint data - NEW SECTION
        parts = checkpoint_data.split("--- CONVERSATION HISTORY ---\n\n")
        file_content_part = parts[0].strip() # Biography text part
        conversation_history_text = parts[1].strip() if len(parts) > 1 else "" # Conversation part, if exists

        session['file_content'] = file_content_part # Restore biography text

        # Reconstruct conversation history - NEW SECTION
        session['conversation'] = [{"role": "system", "content": walt_prompt}] # Start with system prompt
        if conversation_history_text:
            conversation_messages = []
            for line in conversation_history_text.strip().split('\n'):
                if line.strip(): # Ignore empty lines
                    role, content = line.split(':', 1) # Split role: content
                    conversation_messages.append({"role": role.strip(), "content": content.strip()})
            session['conversation'].extend(conversation_messages) # Add parsed messages


        session['biography_outline'] = get_biography_outline()
        session.modified = True

        # Try to extract user's name from conversation history (basic approach)
        user_name = "friend"  # Default if name not found
        for message in reversed(session['conversation']):  # Check conversation history for name
            if message['role'] == 'assistant' and "What's your name?" in message['content']:
                previous_user_message = session['conversation'][session['conversation'].index(message) - 1] if session['conversation'].index(message) > 0 else None  # Get user's message before "What's your name?"
                if previous_user_message and previous_user_message['role'] == 'user':
                    user_name_potential = previous_user_message['content'].strip()
                    if user_name_potential:  # Basic name validation
                        user_name = user_name_potential
                        break  # Exit once name found

        # Generate a simple progress summary (basic example - improve later)
        chapters_discussed = 0
        for chapter_data in session['biography_outline']:
            if chapter_data['status'] == 'Complete':  # Assuming you'll have a 'status' field and update it elsewhere
                chapters_discussed += 1
        progress_summary = f"So far, we've made progress on {chapters_discussed} chapters of your biography." if chapters_discussed > 0 else "We're ready to pick up where we left off."

        # Welcome them back with personalized message and summary
        welcome_phrase = f"Welcome back, {user_name}! Hi, I am Walt. It's great to continue your story. {progress_summary} Ready to jump back in?"

        # Update the conversation history with the new state
        session['conversation'].append({"role": "assistant", "content": welcome_phrase})

        return jsonify({"response": welcome_phrase, "biography_outline": session['biography_outline']})

    except Exception as e:
        print(f"Error processing checkpoint: {e}")
        return jsonify({"error": str(e)}), 500

@walt_bp.route('/create_checkpoint', methods=['POST'])
def create_checkpoint():
    try:
        checkpoint_data_text = session.get('file_content', '')  # Get file_content directly as text
        bio_prompt_content = ""
        try:
            with open('walt/bio_creator_prompt.txt', 'r', encoding='utf-8') as f:  # ADDED: Read bio_creator_prompt.txt
                bio_prompt_content = f.read()
        except Exception as e:
            logging.error(f"Error reading bio_prompt.txt: {e}")
            bio_prompt_content = "Error loading bio creator prompt."  # Fallback if file not read

        conversation_text = "" # NEW: Get conversation history
        current_conversation = session.get('conversation', [])
        for message in current_conversation:
            if message['role'] in ['system', 'user', 'assistant']: # Include system role for full context
                conversation_text += f"{message['role']}: {message['content']}\n"

        combined_checkpoint_content = bio_prompt_content + "\n\n" + checkpoint_data_text + "\n\n--- CONVERSATION HISTORY ---\n\n" + conversation_text # MODIFIED: Include conversation

        logging.info(f"Checkpoint data being created (with conversation): {combined_checkpoint_content[:100]}...")  # Log start of data

        return jsonify({"checkpoint_data": combined_checkpoint_content})  # Return combined text

    except Exception as e:
        logging.error(f"Error creating checkpoint: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@walt_bp.route('/walt_process_checkpoint', methods=['POST'])
def walt_process_checkpoint():
    checkpoint_data_text = session.get('file_content', '')  # Get file_content directly as text
    bio_prompt_content = ""
    api_response_text_safe = ""  # Initialize to handle cases where API call fails

    try:
        try:
            with open('walt/bio_creator_prompt.txt', 'r', encoding='utf-8') as f:  # Read bio_creator_prompt.txt
                bio_prompt_content = f.read()
        except Exception as e:
            logging.error(f"Error reading bio_prompt.txt: {e}")
            return jsonify({"error": f"Error loading bio creator prompt: {str(e)}"}), 500  # Return JSON error

        conversation_text = ""  # Get conversation text for API call
        current_conversation = session.get('conversation', [])
        for message in current_conversation:
            if message['role'] in ['user', 'assistant']:  # Filter for user and assistant roles
                conversation_text += f"{message['role']}: {message['content']}\n"

        desired_tone = request.form.get('tone', 'default')
        tone_instruction = ""
        if desired_tone != 'default':
            tone_instruction = f" Write the biography in a {desired_tone} tone."

        api_input_text = bio_prompt_content + tone_instruction + "\n\n" + checkpoint_data_text + "\n\n--- CONVERSATION ---\n\n" + conversation_text  # Combine for API

        client = openai.Client()  # Call OpenAI API
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": api_input_text}],  # Send combined text prompt
            temperature=0.7,
            max_tokens=700,
        )
        api_response_text = response.choices[0].message.content.strip()  # API response

        api_response_text_safe = api_response_text.replace("<", "<").replace(">", ">")  # Escape HTML

        file_content_for_download = checkpoint_data_text + "\n\n" + api_response_text_safe  # Append API response to existing content

        combined_output_content = file_content_for_download  # Display combined content

        session['file_content'] = file_content_for_download
        session.modified = True  # Ensure session is marked as modified

        return jsonify({  # Return checkpoint data (for file) and api response (for display)
            "checkpoint_data": file_content_for_download,
            "api_response": combined_output_content  # Return COMBINED content for display
        })

    except Exception as e:
        logging.error(f"Error processing checkpoint and calling API: {e}", exc_info=True)
        error_message = f"Error processing checkpoint and calling API: {str(e)}"
        api_response_text_safe = error_message  # Still set a safe error message for display.
        return jsonify({"error": error_message, "api_response": api_response_text_safe}), 500  # Return JSON error with message and safe response for display


@walt_bp.route('/saveTextAsFileDownload', methods=['POST'])  # Keep old route for file download part only
def saveTextAsFileDownload():  # Keep separate function for actual download - UNCHANGED
    try:
        data = request.get_json()
        checkpoint_data = data.get('checkpoint_data')  # Expect plain text directly

        if not checkpoint_data:
            return jsonify({"error": "No checkpoint data to save"}), 400

        # Return the checkpoint data directly as text
        logging.info(f"Checkpoint data being sent for download: {checkpoint_data[:50]}...")  # Debug log start of data
        return jsonify({"fileContent": checkpoint_data})  # Return text directly for download

    except Exception as e:
        logging.error(f"Error return and saving checkpoint from saveTextAsFileDownload: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500


# Helper function to get biography outline (Improvement #5 - Data Driven Outline)
def get_biography_outline():
    return [
        {"chapter": 1, "title": "Hook – A Defining Moment", "status": "TBD"},
        {"chapter": 2, "title": "Origins – Early Life & Influences", "status": "TBD"},
        {"chapter": 3, "title": "Call to Action – First Big Decision", "status": "TBD"},
        {"chapter": 4, "title": "Rising Conflict – Struggles & Growth", "status": "TBD"},
        {"chapter": 5, "title": "The Climax – Defining Achievements", "status": "TBD"}
    ]


--- FILE: walt/templates/walt_window.html ---

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walt the Biographer</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1E2A38;
            color: #E5E5E5;
            padding: 20px;
            text-align: center;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        h1 {
            color: #2D9CDB;
            margin-bottom: 5px;
        }

        p.tagline {
            font-style: italic;
            color: #AEBCCF;
            margin-bottom: 20px;
        }

        #uploadButtonContainer {
            text-align: center; /* Center the button */
            margin-bottom: 20px;
        }

        #uploadButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #27AE60;
            color: white;
            border: none;
            border-radius: 6px;
            /* Make height one line and width auto adjust */
            height: auto;
            width: auto;
            white-space: nowrap; /* Prevent text wrapping */
        }

        input[type="file"] {
            display: none;
        }

        .chat-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            flex: 1;
            width: 100%;
            box-sizing: border-box;
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 10px;
        }

        .chat-title {
            text-align: left;
            margin-bottom: 10px;
            color: #2D9CDB;
        }

        .chat-output {
            flex: 1;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #2A3D55;
            color: #D9E1EC;
            min-height: 400px; /* Min height of 400px */
            height: 450px; /* Adjusted height to fit 18 lines, approximately */
            text-align: left;
            white-space: pre-wrap;
            overflow-y: auto;
            box-sizing: border-box;
            font-size: 16pt; /* Font size set to 16pt */
            align-items: flex-start;
        }

        .chat-input {
            flex: 1;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 10px;
        }

        .prompt-area {
            display: flex;
            flex-direction: column;
            height: 100%; /* Make sure prompt area takes full height */
        }

        textarea {
            width: 100%;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            resize: vertical;
            flex: 1; /* Textarea takes up remaining space */
            box-sizing: border-box;
            font-size: 16pt; /* Font size set to 16pt */
            background-color: #3d597a; /* Light blue */
            overflow-y: auto; /* Enable vertical scrolling */
            color: #D9E1EC;
        }

        #submitButton {
           padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: gold;
            color: dimgrey;
            border: none;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
            height: auto;
            align-self: flex-end; /* Align Submit button to bottom */
}

        h3.dataNote {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #AEBCCF;
        }

        #saveButton {
            text-align: center;
            align-self: center;
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #27AE60;
            color: white;
            border: none;
            border-radius: 6px;
            /* Make height one line and width auto adjust */
            height: auto;
            width: auto;
            white-space: nowrap; /* Prevent text wrapping */
        }


        #sessionSummary {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #2A3D55;
            white-space: pre-wrap;
            overflow-y: auto;
            min-height: 0; /*Removes min height so no shape present*/
            text-align: left;
            box-sizing: border-box;
            font-size: 1.2em;
            display:none; /*Hides the shape*/
        }

        #checkpointOutput { /* Renamed from combinedOutput to checkpointOutput, now for combined output */
            width: 90%;
            margin: 10px auto;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #4C657E; /* Changed to API output style */
            color: #D9E1EC;
            text-align: left;
            white-space: pre-wrap;
            overflow-y: auto; /* Enable scroll if content overflows */
            max-height: 250px; /* Increased max height */
            box-sizing: border-box;
            font-size: 1.2em;
        }

        /* Improvement #5: Biography Outline Styles */
        .biography-outline {
            text-align: left;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #2A3D55;
            color: #D9E1EC;
        }

        .biography-outline h2 {
            color: #2D9CDB;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .biography-outline ul {
            list-style: none;
            padding-left: 20px;
        }

        .biography-outline li {
            margin-bottom: 5px;
        }

        .chapter-title {
            font-weight: bold;
        }

        .chapter-status-tbd {
            color: #AEBCCF; /* Greyed out for TBD chapters */
            font-style: italic;
        }
        .chapter-status-complete {
            color: #27AE60; /* Green for completed chapters */
            font-weight: bold;
        }

        /* New Styles for layout and "Craft Biography" Button */
        .checkpoint-area {
            display: flex;
            flex-direction: column; /* Stack items vertically */
            justify-content: center; /* Center items horizontally in container */
            align-items: center; /* Center items horizontally in flex direction (which is column now) */
            margin-top: 20px;
            gap: 20px; /* Space between tone selector area and craft button */
        }

        .tone-and-craft-group {
            display: flex; /* Arrange tone selector and craft button horizontally */
            justify-content: center; /* Center content horizontally within this group */
            align-items: flex-end; /* Align items to the bottom of this group */
            gap: 20px; /* Space between tone selector and craft button inside group */
            width: auto; /* Adjust width to content */
            margin: 0 auto; /* Center the tone-and-craft-group itself if needed within checkpoint-area */
        }


        .tone-selector-area {
            text-align: left; /* Align tone selector to the left */
            flex-grow: 1; /* Allow tone selector area to take available space if needed - not needed now but keep */
            display: flex; /* Use flexbox for horizontal alignment */
            align-items: baseline; /* Align label and select text baselines */
            gap: 10px; /* Space between label and select */
            justify-content: flex-end; /* Align to the right side - now within tone-and-craft-group */
        }

        .tone-selector-area label {
            margin-bottom: 0; /* Remove default margin for label */
        }


        #craftBiographyButton {
            padding: 15px 30px; /* Larger padding */
            font-size: 20px; /* Larger font size */
            cursor: pointer;
            background-color: #FFA500; /* Example: Orange color */
            color: black;
            border: none;
            border-radius: 8px; /* Slightly more rounded */
            font-weight: bold; /* Bold text */
            box-shadow: 0 4px 8px rgba(255, 165, 0, 0.5); /* Example shadow */
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            white-space: nowrap; /* Prevent text wrapping */
            /* align-self: flex-end;  Not needed anymore as alignment is within tone-and-craft-group */
        }

        #craftBiographyButton:hover {
            background-color: #FF8C00; /* Darker orange on hover */
            transform: scale(1.05); /* Slight scale up on hover */
            box-shadow: 0 6px 12px rgba(255, 165, 0, 0.7); /* Enhanced shadow on hover */
        }

        .save-checkpoint-area {
            text-align: center; /* Center the save checkpoint button */
            margin-top: 20px; /* Add some space above the button */
        }


    </style>
    <script>
        // All the code here is to ensure it is loaded at the top level scope.
        let uploaded_content = ""; //Global variable to store uploaded content
        let storyUpload; // Declare storyUpload outside the event listener
        let biographyOutline; // For storing biography outline (Improvement #5)

        function submitPrompt() {
            let userInput = document.getElementById("userPrompt").value;
            let chatOutput = document.getElementById("chatOutput");
            let toneSelector = document.getElementById("toneSelector"); // Improvement #4
            let selectedTone = toneSelector.value; // Get selected tone

            chatOutput.textContent = "Loading...";
            sendToOpenAI(userInput, chatOutput, uploaded_content, selectedTone); // Send tone
            document.getElementById("userPrompt").value = "";
        }

         function sendToOpenAI(userInput, chatOutput, fileContent, tone) { // Accept tone
            // Get CSRF token from cookie
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');

            fetch("/walt_analyze", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
                 body: "user_query=" + encodeURIComponent(userInput) + "&uploaded_content=" + encodeURIComponent(fileContent) + "&tone=" + encodeURIComponent(tone) // Send tone
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    chatOutput.textContent = "Error: " + data.error;
                } else {
                    chatOutput.textContent = data.response;
                    if (data.biography_outline) { // Improvement #5: Update outline display
                        biographyOutline = data.biography_outline;
                        updateBiographyOutlineDisplay();
                    }
                }
            })
            .catch(error => {
                chatOutput.textContent = "Error: " + error.message;
            });
        }


         function getStoryBoard(){
            let chatOutput = document.getElementById("chatOutput").textContent;
            return chatOutput
        }

       function saveTextAsFile() {
            // Get CSRF token from cookie
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');
             let chatOutput = document.getElementById("chatOutput");  // Get chatOutput for feedback
             let toneSelector = document.getElementById("toneSelector"); // Improvement #4
             let selectedTone = toneSelector.value; // Get selected tone


            chatOutput.textContent = "Processing Checkpoint and Creating File... Please wait."; // Update chatOutput for processing message

            fetch("/walt_process_checkpoint", { // Call the NEW route
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
                body: "tone=" + encodeURIComponent(selectedTone) // Send tone for bio creation (Improvement #4)
            })
            .then(response => response.text()) // Changed to .text() to handle plain text API responses
            .then(textResponse => { // Handle text response, not JSON
                try {
                    const data = JSON.parse(textResponse); // Try to parse as JSON first (for structured responses)
                    if (data.error) {
                        alert("Error creating checkpoint: " + data.error);
                        chatOutput.textContent = "API Error: " + data.error; // Display API error in chatOutput
                    } else {
                        // If valid JSON, handle as before
                        const fileContent = data["checkpoint_data"];

                        // checkpointOutput.textContent = data["api_response"]; // No longer update checkpointOutput
                        chatOutput.textContent += "\n\nCheckpoint file created and download started."; // Inform user in chatOutput

                        console.log("fileContent from server", fileContent)

                        const textFileAsBlob = new Blob([fileContent], { type: 'text/plain' });
                        const fileNameToSaveAs = "sessionStory.txt";

                        const downloadLink = document.createElement("a");
                        downloadLink.download = fileNameToSaveAs;
                        downloadLink.innerHTML = "Download File";
                        downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                        downloadLink.style.display = "none";

                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                    }
                } catch (e) {
                    // If JSON parsing fails, treat the whole response as plain text
                    console.warn("Response is not JSON, treating as plain text:", textResponse);
                    // checkpointOutput.textContent = textResponse; // No longer update checkpointOutput
                    chatOutput.textContent += "\n\nError processing checkpoint, but download may still start.\nRaw response: " + textResponse; // Inform user in chatOutput

                     // Still trigger file download for checkpoint even if API response is not JSON
                     fetch('/saveTextAsFileDownload', { // Call download endpoint separately
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ checkpoint_data: chatOutput.textContent }) // Send current chatOutput text for download (might not be ideal, consider revising backend to return consistent checkpoint data)
                    })
                    .then(downloadResponse => downloadResponse.json()) // Expect JSON for download trigger
                    .then(downloadData => {
                        if (downloadData.fileContent) {
                            const textFileAsBlob = new Blob([downloadData.fileContent], { type: 'text/plain' });
                            const fileNameToSaveAs = "sessionStory.txt";
                            const downloadLink = document.createElement("a");
                            downloadLink.download = fileNameToSaveAs;
                            downloadLink.innerHTML = "Download File";
                            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                            downloadLink.style.display = "none";
                            document.body.appendChild(downloadLink);
                            downloadLink.click();
                            document.body.removeChild(downloadLink);
                        } else if (downloadData.error) {
                            alert("Error triggering download after API issue: " + downloadData.error);
                            chatOutput.textContent += "\n\nDownload Error: " + downloadData.error; // Inform user of download error in chatOutput
                        }
                    })
                    .catch(downloadError => {
                        alert("Error triggering download after API issue: " + downloadError.message);
                        chatOutput.textContent += "\n\nDownload Fetch Error: " + downloadError.message; // Inform user of download fetch error in chatOutput
                    });
                }
            })
            .catch(error => {
                chatOutput.textContent = "Fetch Error: " + error.message; // Display fetch error in chatOutput
            });
        }

        function sendCheckpointData(fileContent) {
              try {
                // Get CSRF token from cookie
                function getCookie(name) {
                    const value = `; ${document.cookie}`;
                    const parts = value.split(`; ${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
                }

                const csrfToken = getCookie('csrf_token');

                fetch("/load_checkpoint", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                        "X-CSRFToken": csrfToken
                    },
                    body: "checkpoint_data=" + encodeURIComponent(fileContent)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        document.getElementById("chatOutput").textContent = "Error: " + data.error;
                    } else {
                        document.getElementById("chatOutput").textContent = data.response;
                        if (data.biography_outline) { // Improvement #5: Load and display outline
                            biographyOutline = data.biography_outline;
                            updateBiographyOutlineDisplay();
                        }
                        sendLoadMessage(); // Added message on upload
                    }
                })
                .catch(error => {
                    document.getElementById("chatOutput").textContent = "Error loading checkpoint.";
                });
            } catch (error) {
                console.error("Error in sendCheckpointData:", error);
                document.getElementById("chatOutput").textContent = "Error loading checkpoint.";
            }
        }

        function sendLoadMessage() {
            let chatOutput = document.getElementById("chatOutput");
            chatOutput.textContent ="Oh I see! I'd forgotten what we already did. Wonderful";
         }
         // This function is triggered when the "Start at last Checkpoint" is pressed
         function uploadStory() {
              console.log("Firing Upload Story Trigger");
              if (storyUpload) {
                  storyUpload.click(); //Programitcally fire "load a checkpoint file."
               } else {
                 console.error("storyUpload element not found");
               }

           }


        // Function to update biography outline display (Improvement #5)
        function updateBiographyOutlineDisplay() {
            const outlineDiv = document.getElementById('biographyOutline');
            if (!biographyOutline || !outlineDiv) return;

            let outlineHTML = '<h2>Biography Outline</h2><ul>';
            biographyOutline.forEach(chapter => {
                const statusClass = chapter.status === 'Complete' ? 'chapter-status-complete' : 'chapter-status-tbd';
                outlineHTML += `<li><span class="chapter-title">Chapter ${chapter.chapter}: ${chapter.title}</span> - <span class="${statusClass}">${chapter.status}</span></li>`;
            });
            outlineHTML += '</ul>';
            outlineDiv.innerHTML = outlineHTML;
        }


        //Event Handling
        document.addEventListener('DOMContentLoaded', function() {
            storyUpload = document.getElementById("story_upload"); // Define at document load
            biographyOutline = {{ biography_outline|tojson }}; // Initialize biographyOutline from template (Improvement #5)
            updateBiographyOutlineDisplay(); // Initial outline display (Improvement #5)
            const chatOutput = document.getElementById("chatOutput");
            const initialMessage = "{{ initial_message|default('') | safe }}"; // Get initial message from template

            if (initialMessage) { // Check if initial message exists
                chatOutput.textContent = initialMessage; // Set initial message in chat output
            }


             console.log("Story Upload: Document is loaded");
            if (storyUpload) {
               //Event
               storyUpload.addEventListener("change", function(event) { //Make sure event is captured
                    console.log("Event Listener Triggered");
                    if (this.files && this.files[0]) {
                      const fileInput = document.getElementById("story_upload");
                      const chatOutput = document.getElementById("chatOutput");

                      const file = fileInput.files[0];

                       const reader = new FileReader();
                          //Set value for upload
                         reader.onload = function(event) {
                               try{
                                    console.log ("Story Uploaded to the Chat Output", event.target.result); //Check log before
                                    //Capture the file upload
                                    uploaded_content = event.target.result;

                                    //Display Load
                                    chatOutput.textContent = "Loading Checkpoint...";  // Display loading message

                                    //Load the checkpoint
                                     sendCheckpointData(event.target.result);
                                }

                                catch (error){
                                    chatOutput.textContent = "Error loading file: " + event.target.error;
                                }
                         };

                         reader.onerror = function(event) {
                            chatOutput.textContent = "Error reading file: " + event.target.error;
                             console.error("Error reading file:", event.target.error);
                        };

                        reader.readAsText(file);
                     }
                  })
            } else {
               console.log("Story Upload does not exist")
            }
        })

        window.onload = function() {
            document.getElementById("chatOutput").textContent = "";  // Clear default text
        };
    </script>
</head>
<body>
    <h1>Walt the Biographer</h1>
    <p class="tagline">I want to write your story!</p>

       <div id="uploadButtonContainer">
        <button id="uploadButton" onclick="uploadStory()">Start at last Checkpoint</button>
    </div>
    <input type="file" id="story_upload" name="story_upload" accept=".txt, .walt">

    <div class="chat-container">
         <div class="chat-area">
            <h2 class="chat-title">Walt</h2>
            <div class="chat-output" id="chatOutput"></div>
        </div>
        <div class="chat-area">
            <h2 class="chat-title">Your Prompts</h2>
            <div class="prompt-area">
                <textarea id="userPrompt" placeholder="Enter your prompt" rows="13"></textarea>
                <button id="submitButton" onclick="submitPrompt()">Submit</button>
            </div>
        </div>
    </div>

    <h3 class="dataNote">Note: No data is saved by this application, the only memory is through this file alone.</h3>

    <div class="save-checkpoint-area">
        <button id="saveButton" onclick="saveTextAsFile()">Create Checkpoint File and Analyze</button>
    </div>

    <div class="checkpoint-area">
        <div class="tone-and-craft-group">  <!-- NEW GROUPING DIV -->
            <div class="tone-selector-area">
                <label for="toneSelector">Biography Tone:</label>
                <select id="toneSelector">
                    <option value="default">Default</option>
                    <option value="humorous">Humorous</option>
                    <option value="reflective">Reflective</option>
                    <option value="dramatic">Dramatic</option>
                    <option value="inspirational">Inspirational</option>
                </select>
            </div>
            <div>
                <button id="craftBiographyButton">Craft Biography</button>
            </div>
        </div>
    </div>


    <div id="sessionSummary"></div>
</body>
</html>

--- FILE: walt/templates/walt_splash.html ---

<!-- file: walt/templates/walt_splash.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Walt Biographer</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1E2A38;
            color: #E5E5E5;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex; /* Enable flexbox for body */
            justify-content: center;
            align-items: center;
        }

        .splash-container {
            display: flex; /* Flex container for image/title and buttons */
            width: 80%; /* Adjust as needed, max width of splash screen */
            max-width: 1200px;
            height: 70%; /* Adjust as needed, max height of splash screen */
            max-height: 800px;
            border-radius: 12px;
            background: #2A3D55;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Clip any overflowing content */
        }

        .splash-left {
            flex: 1; /* Take 50% of the container width */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            text-align: center;
        }

        .splash-right {
            flex: 1; /* Take 50% of the container width */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #1E2A38; /* Slightly darker background for buttons side */
        }


        .splash-image {
            max-width: 80%; /* Control image size within its container */
            max-height: 60%;
            height: auto;
            margin-bottom: 20px; /* Space below image */
        }

        h1 {
            color: #2D9CDB;
            font-size: 2.5em; /* Slightly smaller than before, adjust as needed */
            margin: 0; /* Remove default margins */
        }

        .splash-tagline {
            font-style: italic;
            color: #D9E1EC;
            font-size: 1.4em; /* Adjust font size as needed */
            margin-bottom: 15px; /* Space below tagline */
        }

        .splash-get-started {
            color: #AEBCCF;
            font-size: 1em; /* Smaller font size for "Get Started" */
            margin-bottom: 10px; /* Space below "Get Started" */
        }


        .splash-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 80%; /* Buttons width relative to right container */
            max-width: 400px; /* Max width for buttons */
            margin-top: 10px; /* Space above buttons - reduced slightly */
        }

        .splash-button {
            padding: 15px 20px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #27AE60;
            color: white;
            border: none;
            border-radius: 8px;
            transition: background-color 0.3s ease;
            white-space: nowrap; /* Prevent button text wrapping */
        }

        .splash-button:hover {
            background-color: #1F8A4C;
        }

        #story_upload {
            display: none; /* Hide the file input initially */
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .splash-container {
                flex-direction: column; /* Stack image/title and buttons vertically */
                width: 95%; /* Take up more width on smaller screens */
                height: auto; /* Adjust height to content */
                text-align: center; /* Center text on smaller screens */
            }
            .splash-left, .splash-right {
                flex: none; /* No flex for stacked layout */
                width: 100%; /* Full width when stacked */
            }
             .splash-image {
                max-width: 50%; /* Smaller image on mobile */
                max-height: 40%;
             }
            h1 {
                font-size: 2em; /* Smaller title on mobile */
            }
            .splash-tagline {
                font-size: 1.2em; /* Smaller tagline on mobile */
            }
             .splash-buttons {
                width: 95%; /* Wider buttons on mobile */
            }
        }
    </style>
    <script>
        function beginNewBiography() {
            window.location.href = "/walt?new_bio=true"; // Corrected path to just "/walt"
        }

        function loadCheckpointFile() {
            document.getElementById('story_upload').click(); // Trigger file input
        }

        document.addEventListener('DOMContentLoaded', function() {
            const storyUpload = document.getElementById("story_upload");
            if (storyUpload) {
                storyUpload.addEventListener("change", function(event) {
                    if (this.files && this.files[0]) {
                        const file = this.files[0];
                        const reader = new FileReader();

                        reader.onload = function(event) {
                            const fileContent = event.target.result;
                            sendCheckpointData(fileContent); // Call existing function to load checkpoint
                        };
                        reader.onerror = function(event) {
                            alert("Error reading file: " + event.target.error);
                            console.error("Error reading file:", event.target.error);
                        };
                        reader.readAsText(file);
                    }
                });
            }
        });

        function sendCheckpointData(fileContent) {
            // Get CSRF token from cookie
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');

            fetch("/walt/load_checkpoint", { // Corrected path to "/walt/load_checkpoint"
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
                body: "checkpoint_data=" + encodeURIComponent(fileContent)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error loading checkpoint: " + data.error);
                } else {
                    window.location.href = "/walt"; // Corrected path to just "/walt"
                }
            })
            .catch(error => {
                alert("Error loading checkpoint.");
            });
        }


    </script>
</head>
<body>
    <div class="splash-container">
        <div class="splash-left">
            <img src="{{ url_for('static', filename='images/walt.png') }}" alt="Walt Biographer" class="splash-image">
            <h1>Walt, the AI Biographer</h1>
        </div>
        <div class="splash-right">
            <p class="splash-tagline">I want to write your unique story!</p> <p class="splash-get-started">Get Started</p>
            <div class="splash-buttons">
                <button class="splash-button" onclick="beginNewBiography()">Begin New Biography</button>
                <button class="splash-button" onclick="loadCheckpointFile()">Load Your Checkpoint file</button>
            </div>
        </div>
    </div>
    <input type="file" id="story_upload" name="story_upload" accept=".txt, .walt">
</body>
</html>

--- FILE: walt2/walt2.py ---

from flask import Blueprint, render_template, request, jsonify, session, send_file
import os
import openai
import logging
import json
from werkzeug.utils import secure_filename
from io import StringIO

walt2_bp = Blueprint('walt2', __name__, template_folder='templates')

def format_openai_text(text):
    formatted_text = text.replace("\n", "<br>")
    return formatted_text

@walt2_bp.route('/')
def walt_window_splash(): # Renamed to walt_window_splash to be more descriptive
    return render_template('walt_splash2.html')

@walt2_bp.route('/new_bio_start', methods=['GET'])
def new_bio_start():
    session.pop('conversation', None)
    session.pop('biography_outline', None)
    session.pop('file_content', None)
    session.pop('loaded_checkpoint_conversation', None) # Clear loaded checkpoint history

    try:
        with open('walt2/walt_prompts/welcome.txt', 'r', encoding='utf-8') as f:
            welcome_prompt = f.read()
    except FileNotFoundError:
        return jsonify({"error": "welcome.txt prompt not found!"}), 500

    try:
        client = openai.Client()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are Walt, the biographer, starting a new biography."},
                {"role": "user", "content": welcome_prompt}
            ],
            temperature=0.7,
            max_tokens=200
        )
        initial_message = response.choices[0].message.content.strip()
        session['conversation'] = [{"role": "system", "content": get_walt_prompt_content()}, {"role": "assistant", "content": initial_message}]
        session['biography_outline'] = get_biography_outline()
        session.modified = True
        # Return JSON instead of rendering template for new_bio_start as well, for consistency.
        return jsonify({
            "initial_message": initial_message,
            "biography_outline": session['biography_outline']
        })

    except Exception as e:
        logging.error(f"OpenAI API error on new bio start: {e}")
        return jsonify({
            "error": f"Error starting new bio: {str(e)}",
            "biography_outline": session.get('biography_outline') # Still return outline if available
        })


@walt2_bp.route('/app') # NEW route for /walt2/app - serves main app window
def walt_window(): # Original walt_window function - now for /walt2/app
    return render_template('walt_window2.html', biography_outline=session.get('biography_outline'), initial_message=None)

@walt2_bp.route('/continue_bio_start', methods=['POST'])
def continue_bio_start():
    checkpoint_data = request.form.get('checkpoint_data')
    if not checkpoint_data:
        logging.warning("No checkpoint data received in continue_bio_start request.") # Enhanced logging
        return jsonify({"error": "No checkpoint data received"}), 400

    session.pop('conversation', None)
    session.pop('biography_outline', None)
    session.pop('file_content', None)
    session.pop('loaded_checkpoint_conversation', None) # Clear any old loaded history

    logging.debug(f"Checkpoint data received:\n{checkpoint_data[:200]}...") # Log the beginning of checkpoint data

    try: # ADDED try...except BLOCK
        try:
            with open('walt2/walt_prompts/continue.txt', 'r', encoding='utf-8') as f:
                continue_prompt_base = f.read()
        except FileNotFoundError:
            return jsonify({"error": "continue.txt prompt not found!"}), 500

        continue_prompt = continue_prompt_base + "\n\nCHECKPOINT FILE CONTENT:\n" + checkpoint_data

        try:
            client = openai.Client()
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are Walt, the biographer, continuing a biography from a checkpoint."},
                    {"role": "user", "content": continue_prompt}
                ],
                temperature=0.7,
                max_tokens=200
            )
            initial_message = response.choices[0].message.content.strip()
            logging.debug(f"Initial message from OpenAI API: {initial_message}") # Log initial message

            parts = checkpoint_data.split("--- CONVERSATION HISTORY ---\n\n")
            file_content_part = parts[0].strip()
            conversation_history_text = parts[1].strip() if len(parts) > 1 else ""

            session['file_content'] = file_content_part
            logging.debug(f"File content part extracted:\n{file_content_part[:200]}...") # Log file content part

            loaded_conversation_history = [] # Initialize loaded conversation history
            if conversation_history_text:
                logging.debug(f"Conversation history text found:\n{conversation_history_text[:200]}...") # Log conversation history text
                conversation_messages = []
                valid_roles = ['system', 'user', 'assistant'] # Define valid roles
                for line in conversation_history_text.strip().split('\n'):
                    if line.strip():
                        try: # Add try-except for line parsing
                            role, content = line.split(':', 1)
                            role = role.strip() # Strip whitespace from role
                            if role in valid_roles: # Check if role is valid
                                conversation_messages.append({"role": role, "content": content.strip()})
                                logging.debug(f"Parsed line - Role: {role}, Content: {content.strip()[:100]}...") # Log parsed line
                            else:
                                logging.warning(f"Skipping line with invalid role: {role}. Line: {line}") # Log skipped lines
                        except ValueError as ve:
                            logging.warning(f"Error parsing conversation history line: {line}. Error: {ve}") # Log parsing errors
                loaded_conversation_history = conversation_messages # Store loaded conversation history
            else:
                logging.debug("No conversation history text found in checkpoint data.") # Log if no history


            session['conversation'] = [{"role": "system", "content": get_walt_prompt_content()}] # Start with system prompt and ONLY SYSTEM PROMPT INITIALLY
            session['conversation'].extend(loaded_conversation_history) # STORE LOADED CONVERSATION HISTORY IN SESSION - BUT DO NOT DISPLAY IT YET
            # session['conversation'].append({"role": "assistant", "content": initial_message}) # DO NOT APPEND WELCOME MESSAGE HERE - SEND IT SEPARATELY to DISPLAY

            session['biography_outline'] = get_biography_outline()
            session.modified = True

            logging.debug(f"Session variables after checkpoint load: \nConversation: {session.get('conversation')}\nBiography Outline: {session.get('biography_outline')}\nFile Content (start): {session.get('file_content', '')[:200]}...\nLoaded Conversation History (start): {session.get('conversation')[:1]} -- SHOULD INCLUDE HISTORY IN SESSION BUT NOT DISPLAYED YET") # Log session variables

            # Return JSON response with initial message and biography outline
            return jsonify({
                "initial_message": initial_message, # SEND INITIAL MESSAGE FOR DISPLAY ONLY
                "biography_outline": session['biography_outline']
            })

        except Exception as openai_e: # SPECIFICALLY CATCH OPENAI EXCEPTIONS
            logging.error(f"OpenAI API error in continue_bio_start: {openai_e}", exc_info=True) # LOG OPENAI ERROR WITH TRACEBACK
            return jsonify({
                "error": f"Error continuing bio (OpenAI API): {str(openai_e)}",
                "biography_outline": session.get('biography_outline') # Still return outline if available
            })

    except Exception as e: # CATCH ALL OTHER EXCEPTIONS IN THE ROUTE
        logging.error(f"General error in continue_bio_start: {e}", exc_info=True) # LOG GENERAL ERROR WITH TRACEBACK
        return jsonify({
            "error": f"Error processing checkpoint: {str(e)}"
        }) # RETURN JSON ERROR FOR AJAX CALL


def get_walt_prompt_content():
    try:
        with open('walt2/walt_prompts/walt_prompt.txt', 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        return "Error: walt_prompt.txt not found!"


@walt2_bp.route('/walt_analyze', methods=['POST'])
def walt_analyze():
    user_input = request.form.get('user_query')

    if not user_input:
        return jsonify({"error": "No user query provided"}), 400

    walt_prompt_base = get_walt_prompt_content()
    walt_prompt = walt_prompt_base


    if 'conversation' not in session:
        initial_greeting = "Hi I'm Walt. What's your name?"
        session['conversation'] = [{"role": "system", "content": walt_prompt},
                                     {"role": "assistant", "content": initial_greeting}]
        session['biography_outline'] = get_biography_outline()


    session['conversation'].append({"role": "user", "content": user_input + ".  Continue to help me build my biography."})

    try:
        client = openai.Client()
        logging.info(f"OpenAI Request Messages: {session['conversation']}")

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=session['conversation'],
            temperature=0.7,
            max_tokens=256,
            top_p=1
        )
        api_response = response.choices[0].message.content.strip()
        session['conversation'].append({"role": "assistant", "content": api_response})
        session.modified = True

        return jsonify({"response": api_response, "biography_outline": session['biography_outline']})

    except Exception as e:
        logging.error(f"OpenAI API Error: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500


@walt2_bp.route('/create_checkpoint', methods=['POST'])
def create_checkpoint(): # MODIFIED FUNCTION
    try:
        checkpoint_data_text = session.get('file_content', '')
        bio_prompt_content = ""
        try:
            with open('walt2/walt_prompts/bio_creator_prompt.txt', 'r', encoding='utf-8') as f:
                bio_prompt_content = f.read()
        except Exception as e:
            logging.error(f"Error reading bio_prompt.txt: {e}")
            bio_prompt_content = "Error loading bio creator prompt."

        conversation_text = ""
        current_conversation = session.get('conversation', [])

        # EXTEND CONVERSATION HISTORY WITH LOADED CHECKPOINT HISTORY
        extended_conversation = list(session.get('loaded_checkpoint_conversation', [])) # Start with loaded history
        extended_conversation.extend(current_conversation) # Append current history

        extended_conversation_text = "" # Reconstruct extended history text
        for message in extended_conversation:
            if message['role'] in ['user', 'assistant']: # Include user and assistant roles in history
                extended_conversation_text += f"{message['role']}: {message['content']}\n"

        api_input_text = bio_prompt_content + "\n\n" + checkpoint_data_text + "\n\n--- CONVERSATION ---\n\n" + extended_conversation_text # USE EXTENDED HISTORY FOR API

        client = openai.Client() # CALL OPENAI API
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": api_input_text}],
            temperature=0.7,
            max_tokens=700, # Adjust max_tokens as needed
        )
        api_response_text = response.choices[0].message.content.strip() # GET API RESPONSE

        api_response_text_safe = api_response_text.replace("<", "<").replace(">", ">") # Escape HTML if needed

        file_content_for_download = api_response_text_safe + "\n\n--- EXTENDED CONVERSATION HISTORY ---\n\n" + extended_conversation_text # CHECKPOINT FILE CONTAINS API RESPONSE + EXTENDED HISTORY

        session['file_content'] = file_content_for_download # Optionally update session file_content with API response (or combined content if you prefer)
        session.modified = True

        logging.info(f"Checkpoint data being created (API Response + Extended History): {file_content_for_download[:100]}...") # Log combined content

        return jsonify({"checkpoint_data": file_content_for_download}) # Return COMBINED CONTENT as checkpoint data

    except Exception as e:
        logging.error(f"Error processing checkpoint and calling API: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500


@walt2_bp.route('/craft_biography', methods=['POST'])
def craft_biography():
    checkpoint_data_text = session.get('file_content', '')
    conversation_text = ""
    current_conversation = session.get('conversation', [])
    for message in current_conversation:
        if message['role'] in ['user', 'assistant']:
            conversation_text += f"{message['role']}: {message['content']}\n"

    try:
        with open('walt2/walt_prompts/write_bio.txt', 'r', encoding='utf-8') as f:
            write_bio_prompt = f.read()
    except FileNotFoundError:
        return jsonify({"error": "write_bio.txt prompt not found!"}), 500

    api_input_text = write_bio_prompt + "\n\n" + checkpoint_data_text + "\n\n--- CONVERSATION ---\n\n" + conversation_text

    try:
        client = openai.Client()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": api_input_text}],
            temperature=0.7,
            max_tokens=1000,
        )
        biography_content = response.choices[0].message.content.strip()
        formatted_biography = format_openai_text(biography_content)

        formatted_biography_file = biography_content.replace("<br>", "\n")
        filename = "Full_biography.txt"
        with open(filename, 'w', encoding='utf-8') as outfile:
            outfile.write(formatted_biography_file)

        session['file_content'] = biography_content
        session.modified = True

        return jsonify({"api_response": formatted_biography, "file_download_name": filename})

    except Exception as e:
        logging.error(f"Error crafting biography: {e}", exc_info=True)
        error_message = f"Error crafting biography: {str(e)}"
        formatted_error = format_openai_text(error_message)
        return jsonify({"error": error_message, "api_response": formatted_error}), 500


@walt2_bp.route('/saveTextAsFileDownload', methods=['POST'])
def saveTextAsFileDownload():
    try:
        data = request.get_json()
        checkpoint_data = data.get('checkpoint_data')
        file_download_name = data.get('file_download_name', 'sessionStory.txt')

        if not checkpoint_data:
            return jsonify({"error": "No checkpoint data to save"}), 400

        logging.info(f"Checkpoint data being sent for download: {checkpoint_data[:50]}...")

        virtual_file = StringIO()
        virtual_file.write(checkpoint_data)
        virtual_file.seek(0)

        return send_file(
            virtual_file,
            mimetype='text/plain',
            download_name=file_download_name,
            as_attachment=True
        )


    except Exception as e:
        logging.error(f"Error return and saving checkpoint from saveTextAsFileDownload: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500

def get_biography_outline():
    return [
        {"chapter": 1, "title": "Hook – Defining Moment", "status": "TBD"},
        {"chapter": 2, "title": "Origins – Early Life & Influences", "status": "TBD"},
        {"chapter": 3, "title": "Call to Action – First Big Decision", "status": "TBD"},
        {"chapter": 4, "title": "Rising Conflict – Struggles & Growth", "status": "TBD"},
        {"chapter": 5, "title": "The Climax – Defining Achievements", "status": "TBD"}
    ]


--- FILE: walt2/templates/walt_splash2.html ---

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Walt Biographer</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1E2A38;
            color: #E5E5E5;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex; /* Enable flexbox for body */
            justify-content: center;
            align-items: center;
        }

        .splash-container {
            display: flex; /* Flex container for image/title and buttons */
            width: 80%; /* Adjust as needed, max width of splash screen */
            max-width: 1200px;
            height: 70%; /* Adjust as needed, max height of splash screen */
            max-height: 800px;
            border-radius: 12px;
            background: #2A3D55;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Clip any overflowing content */
        }

        .splash-left {
            flex: 1; /* Take 50% of the container width */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            text-align: center;
        }

        .splash-right {
            flex: 1; /* Take 50% of the container width */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #1E2A38; /* Slightly darker background for buttons side */
        }


        .splash-image {
            max-width: 80%; /* Control image size within its container */
            max-height: 60%;
            height: auto;
            margin-bottom: 20px; /* Space below image */
        }

        h1 {
            color: #2D9CDB;
            font-size: 2.5em; /* Slightly smaller than before, adjust as needed */
            margin: 0; /* Remove default margins */
        }

        .splash-tagline {
            font-style: italic;
            color: #D9E1EC;
            font-size: 1.4em; /* Adjust font size as needed */
            margin-bottom: 15px; /* Space below tagline */
        }

        .splash-get-started {
            color: #AEBCCF;
            font-size: 1em; /* Smaller font size for "Get Started" */
            margin-bottom: 10px; /* Space below "Get Started" */
        }


        .splash-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 80%; /* Buttons width relative to right container */
            max-width: 400px; /* Max width for buttons */
            margin-top: 10px; /* Space above buttons - reduced slightly */
        }

        .splash-button {
            padding: 15px 20px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #27AE60;
            color: white;
            border: none;
            border-radius: 8px;
            transition: background-color 0.3s ease;
            white-space: nowrap; /* Prevent button text wrapping */
        }

        .splash-button:hover {
            background-color: #1F8A4C;
        }

        #story_upload {
            display: none; /* Hide the file input initially */
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .splash-container {
                flex-direction: column; /* Stack image/title and buttons vertically */
                width: 95%; /* Take up more width on smaller screens */
                height: auto; /* Adjust height to content */
                text-align: center; /* Center text on smaller screens */
            }
            .splash-left, .splash-right {
                flex: none; /* No flex for stacked layout */
                width: 100%; /* Full width when stacked */
            }
             .splash-image {
                max-width: 50%; /* Smaller image on mobile */
                max-height: 40%;
             }
            h1 {
                font-size: 2em; /* Smaller title on mobile */
            }
            .splash-tagline {
                font-size: 1.2em; /* Smaller tagline on mobile */
            }
             .splash-buttons {
                width: 95%; /* Wider buttons on mobile */
            }
        }
    </style>
    <script>
        function beginNewBiography() {
            console.log("beginNewBiography function called!"); // ADDED LOG
            // Changed to fetch API call
            fetch("/walt2/new_bio_start", {
                method: "GET",
                headers: {
                    'Content-Type': 'application/json' // Expecting JSON response
                },
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error starting new biography: " + data.error);
                } else {
                    console.log("Redirecting to /walt2/app"); // ADDED LOGGING BEFORE REDIRECT
                    sessionStorage.setItem('initial_message', data.initial_message); // Store initial message
                    window.location.href = "/walt2/app"; // Redirect to /walt2/app, the main app route  <--- CHANGED LINE
                }
            })
            .catch(error => {
                alert("Error starting new biography.");
                console.error("Fetch error:", error);
            });
        }

        function loadCheckpointFile() {
            console.log("loadCheckpointFile function called!"); // ADDED LOG
            document.getElementById('story_upload').click(); // Trigger file input
        }

        document.addEventListener('DOMContentLoaded', function() {
            const storyUpload = document.getElementById("story_upload");
            if (storyUpload) {
                storyUpload.addEventListener("change", function(event) {
                    if (this.files && this.files[0]) {
                        const file = this.files[0];
                        const reader = new FileReader();

                        reader.onload = function(event) {
                            const fileContent = event.target.result;
                            sendCheckpointData(fileContent); // Call existing function to load checkpoint
                        };
                        reader.onerror = function(event) {
                            alert("Error reading file: " + event.target.error);
                            console.error("Error reading file:", event.target.error);
                        };
                        reader.readAsText(file);
                    }
                });
            }
        });

        function sendCheckpointData(fileContent) {
            // Get CSRF token from cookie
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');

            fetch("/walt2/continue_bio_start", { // Corrected path to "/walt2/continue_bio_start"
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
                body: "checkpoint_data=" + encodeURIComponent(fileContent)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error loading checkpoint: " + data.error);
                } else {
                     console.log("Redirecting to /walt2/app"); // ADDED LOGGING BEFORE REDIRECT
                     sessionStorage.setItem('initial_message', data.initial_message); // Store initial message
                    window.location.href = "/walt2/app"; // Redirect to  /walt2/app, the main app route  <--- CHANGED LINE
                }
            })
            .catch(error => {
                alert("Error loading checkpoint.");
                console.error("Fetch error:", error);
            });
        }


    </script>
</head>
<body>
    <div class="splash-container">
        <div class="splash-left">
            <img src="{{ url_for('static', filename='images/walt.png') }}" alt="Walt Biographer" class="splash-image">
            <h1>Walt, the AI Biographer</h1>
        </div>
        <div class="splash-right">
            <p class="splash-tagline">I want to write your unique story!</p> <p class="splash-get-started">Get Started</p>
            <div class="splash-buttons">
                <button class="splash-button" onclick="beginNewBiography()">Begin New Bio</button>
                <button class="splash-button" onclick="loadCheckpointFile()">Load Your Checkpoint file</button>
            </div>
        </div>
    </div>
    <input type="file" id="story_upload" name="story_upload" accept=".txt, .walt">
</body>
</html>

--- FILE: walt2/templates/walt_window2.html ---

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walt the Biographer</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1E2A38;
            color: #E5E5E5;
            padding: 20px; /* Keep body padding */
            text-align: center;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        h1 {
            color: #2D9CDB;
            margin-bottom: 5px;
        }

        p.tagline {
            font-style: italic;
            color: #AEBCCF;
            margin-bottom: 20px;
        }

        #uploadButtonContainer {
            margin-bottom: 20px;
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            width: 100%;
            box-sizing: border-box;
            /* padding-left: 10px;  REMOVED padding-left from container*/
            /* padding-right: 10px; REMOVED padding-right from container */
            padding-left: 0px; /* Set container padding-left to 0 */
            padding-right: 0px; /* Set container padding-right to 0 */
        }

        #uploadButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #27AE60;
            color: white;
            border: none;
            border-radius: 6px;
            height: auto;
            width: auto;
            white-space: nowrap;
            margin-left: auto;
            text-align: right;
            margin-right: 20px; /* ADDED margin-right to button */
        }

        #waltImage {
            height: 80px;
            margin-right: 15px;
            align-self: flex-start;
            margin-left: 20px; /* ADDED margin-left to image */
        }


        input[type="file"] {
            display: none;
        }

        .chat-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            flex: 1;
            width: 100%;
            box-sizing: border-box;
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 10px;
        }

        .chat-title {
            text-align: left;
            margin-bottom: 10px;
            color: #2D9CDB;
        }

        .chat-output {
            flex: 1;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #2A3D55;
            color: #D9E1EC;
            min-height: 400px;
            height: 450px;
            text-align: left;
            white-space: pre-wrap;
            overflow-y: auto;
            box-sizing: border-box;
            font-size: 16pt;
            align-items: flex-start;
        }

        .chat-input {
            flex: 1;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 10px;
        }

        .prompt-area {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        textarea {
            width: 100%;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            resize: vertical;
            flex: 1;
            box-sizing: border-box;
            font-size: 16pt;
            background-color: #3d597a;
            overflow-y: auto;
            color: #D9E1EC;
        }

        #submitButton {
           padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: gold;
            color: dimgrey;
            border: none;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
            height: auto;
            align-self: flex-end;
}

        h3.dataNote {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #AEBCCF;
        }

        #saveButton {
            text-align: center;
            align-self: center;
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #27AE60;
            color: white;
            border: none;
            border-radius: 6px;
            height: auto;
            width: auto;
            white-space: nowrap;
        }


        #sessionSummary {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #2A3D55;
            white-space: pre-wrap;
            overflow-y: auto;
            min-height: 0;
            text-align: left;
            box-sizing: border-box;
            font-size: 1.2em;
            display:none;
        }

        #checkpointOutput {
            width: 90%;
            margin: 10px auto;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #4C657E;
            color: #D9E1EC;
            text-align: left;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 250px;
            box-sizing: border-box;
            font-size: 1.2em;
        }

        .biography-outline {
            text-align: left;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #2A3D55;
            color: #D9E1EC;
        }

        .biography-outline h2 {
            color: #2D9CDB;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .biography-outline ul {
            list-style: none;
            padding-left: 20px;
        }

        .biography-outline li {
            margin-bottom: 5px;
        }

        .chapter-title {
            font-weight: bold;
        }

        .chapter-status-tbd {
            color: #AEBCCF;
            font-style: italic;
        }
        .chapter-status-complete {
            color: #27AE60;
            font-weight: bold;
        }

        .checkpoint-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            gap: 20px;
        }

        .tone-and-craft-group {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 20px;
            width: 80%;
            max-width: 600px;
            min-width: 500px;
            padding: 20px;
            background: #2A3D55;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            text-align: left;
            margin-left: auto;
            margin-right: auto;
        }

        .craft-area-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            gap: 20px;
             width: 80%;
            max-width: 900px;
            min-width: 600px;
             padding: 20px;
            background: #2A3D55;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            text-align: left;
            margin-left: auto;
            margin-right: auto;
        }

        .tone-selector-area {
            text-align: left;
            flex-grow: 1;
            display: flex;
            align-items: baseline;
            gap: 10px;
            justify-content: flex-end;
        }

        .tone-selector-area label {
            margin-bottom: 0;
        }


        #craftBiographyButton {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background-color: #FFA500;
            color: black;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(255, 165, 0, 0.5);
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            white-space: nowrap;
            width: 100%;
        }

        #craftBiographyButton:hover {
            background-color: #FF8C00;
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(255, 165, 0, 0.7);
        }


        .save-checkpoint-area {
            text-align: center;
            margin-top: 20px;
        }


    </style>
    <script>
        let uploaded_content = "";
        let storyUpload;
        let biographyOutline;

        function submitPrompt() {
            let userInput = document.getElementById("userPrompt").value;
            let chatOutput = document.getElementById("chatOutput");

            chatOutput.textContent = "Loading...";
            sendToOpenAI(userInput, chatOutput, uploaded_content);
            document.getElementById("userPrompt").value = "";
        }

         function sendToOpenAI(userInput, chatOutput, fileContent) {
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');

            fetch("/walt2/walt_analyze", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
                 body: "user_query=" + encodeURIComponent(userInput) + "&uploaded_content=" + encodeURIComponent(fileContent)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    chatOutput.textContent = "Error: " + data.error;
                } else {
                    chatOutput.textContent = data.response;
                    if (data.biography_outline) {
                        biographyOutline = data.biography_outline;
                        updateBiographyOutlineDisplay();
                    }
                }
            })
            .catch(error => {
                chatOutput.textContent = "Error: " + error.message;
            });
        }


         function getStoryBoard(){
            let chatOutput = document.getElementById("chatOutput").textContent;
            return chatOutput
         }

       function saveTextAsFile() {
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');
             let chatOutput = document.getElementById("chatOutput");

            chatOutput.textContent = "Processing Checkpoint and Creating File... Please wait.";

            fetch("/walt2/create_checkpoint", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error creating checkpoint: " + data.error);
                    chatOutput.textContent = "API Error: " + data.error;
                } else {
                    const fileContent = data["checkpoint_data"];

                    chatOutput.textContent += "\n\nCheckpoint file created and download started.";

                    console.log("fileContent from server", fileContent)

                    const textFileAsBlob = new Blob([fileContent], { type: 'text/plain' });
                    const fileNameToSaveAs = "sessionStory.txt";

                    const downloadLink = document.createElement("a");
                    downloadLink.download = fileNameToSaveAs;
                    downloadLink.innerHTML = "Download File";
                    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                    downloadLink.style.display = "none";

                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                 }
            })
            .catch(error => {
                chatOutput.textContent = "Fetch Error: " + error.message;
            });
        }

        function craftBiography() {
             function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');
            let chatOutput = document.getElementById("chatOutput");
            chatOutput.textContent = "Crafting Biography... Please wait.  This may take a minute.";

            fetch("/walt2/craft_biography", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error crafting biography: " + data.error);
                    chatOutput.textContent = "Error crafting biography: " + data.error;
                } else {
                    chatOutput.innerHTML = data.api_response;

                    const fileContent = data.api_response.replace(/<br>/g, '\n');
                    const textFileAsBlob = new Blob([fileContent], { type: 'text/plain' });
                    const fileNameToSaveAs = data.file_download_name || "Full_biography.txt";
                    const downloadLink = document.createElement("a");
                    downloadLink.download = fileNameToSaveAs;
                    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                    downloadLink.style.display = "none";
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    chatOutput.textContent += "\n\nBiography crafted and download started.";
                }
            })
            .catch(error => chatOutput.textContent = "Error crafting biography: " + error.message);
        }


         function sendCheckpointData(fileContent) {
              try {
                function getCookie(name) {
                    const value = `; ${document.cookie}`;
                    const parts = value.split(`; ${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
                }

                const csrfToken = getCookie('csrf_token');

                fetch("/walt2/continue_bio_start", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                        "X-CSRFToken": csrfToken
                    },
                    body: "checkpoint_data=" + encodeURIComponent(fileContent)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        document.getElementById("chatOutput").textContent = "Error: " + data.error;
                    } else {
                        document.getElementById("chatOutput").textContent = data.initial_message;
                        if (data.biography_outline) {
                            biographyOutline = data.biography_outline;
                            updateBiographyOutlineDisplay();
                        }
                        sendLoadMessage();
                    }
                })
                .catch(error => {
                    document.getElementById("chatOutput").textContent = "Error loading checkpoint.";
                });
            } catch (error) {
                console.error("Error in sendCheckpointData:", error);
                document.getElementById("chatOutput").textContent = "Error loading checkpoint.";
            }
        }

        function sendLoadMessage() {
            let chatOutput = document.getElementById("chatOutput");
            chatOutput.textContent ="Oh I see! I'd forgotten what we already did. Wonderful";
         }

         function uploadStory() {
              console.log("Firing Upload Story Trigger");
              if (storyUpload) {
                  storyUpload.click();
               } else {
                 console.error("storyUpload element not found");
               }
           }

        function displayInitialMessageOnLoad() {
            const initialMessage = sessionStorage.getItem('initial_message');
            if (initialMessage) {
                document.getElementById("chatOutput").textContent = initialMessage;
                sessionStorage.removeItem('initial_message');
            }
        }


        function updateBiographyOutlineDisplay() {
            const outlineDiv = document.getElementById('biographyOutline');
            if (!biographyOutline || !outlineDiv) return;

            let outlineHTML = '<h2>Biography Outline</h2><ul>';
            biographyOutline.forEach(chapter => {
                const statusClass = chapter.status === 'Complete' ? 'chapter-status-complete' : 'chapter-status-tbd';
                outlineHTML += `<li><span class="chapter-title">Chapter ${chapter.chapter}: ${chapter.title}</span> - <span class="${statusClass}">${chapter.status}</span></li>`;
            });
            outlineHTML += '</ul>';
            outlineDiv.innerHTML = outlineHTML;
        }


        document.addEventListener('DOMContentLoaded', function() {
            storyUpload = document.getElementById("story_upload");
            biographyOutline = {{ biography_outline|tojson }};
            updateBiographyOutlineDisplay();
            const chatOutput = document.getElementById("chatOutput");
            const initialMessage = "{{ initial_message|default('') | safe }}";

            displayInitialMessageOnLoad();


             console.log("Story Upload: Document is loaded");
            if (storyUpload) {
               storyUpload.addEventListener("change", function(event) {
                    console.log("Event Listener Triggered");
                    if (this.files && this.files[0]) {
                      const fileInput = document.getElementById("story_upload");
                      const chatOutput = document.getElementById("chatOutput");

                      const file = fileInput.files[0];

                       const reader = new FileReader();
                         reader.onload = function(event) {
                               try{
                                    console.log ("Story Uploaded to the Chat Output", event.target.result);
                                    uploaded_content = event.target.result;
                                    chatOutput.textContent = "Loading Checkpoint...";
                                     sendCheckpointData(event.target.result);
                                }
                                catch (error){
                                    chatOutput.textContent = "Error loading file: " + event.target.error;
                                }
                          };

                          reader.onerror = function(event) {
                             chatOutput.textContent = "Error reading file: " + event.target.error;
                              console.error("Error reading file:", event.target.error);
                         };

                         reader.readAsText(file);
                      }
                   })
             } else {
                console.log("Story Upload does not exist")
             }
         })

         window.onload = function() {
         };
     </script>
 <body>
     <h1>Walt the Biographer</h1>
     <p class="tagline">I want to write your story!</p>

        <div id="uploadButtonContainer">
            <img id="waltImage" src="{{ url_for('static', filename='images/walt.png') }}" alt="Walt Biographer">
         <button id="uploadButton" onclick="uploadStory()">Start at last Checkpoint</button>
     </div>
     <input type="file" id="story_upload" name="story_upload" accept=".txt, .walt">

     <div class="chat-container">
          <div class="chat-area">
             <h2 class="chat-title">Walt</h2>
             <div class="chat-output" id="chatOutput"></div>
         </div>
         <div class="chat-area">
             <h2 class="chat-title">Your Response</h2>  <!-- Changed text here -->
             <div class="prompt-area">
                 <textarea id="userPrompt" placeholder="Enter your prompt" rows="13"></textarea>
                 <button id="submitButton" onclick="submitPrompt()">Submit</button>
             </div>
         </div>
     </div>

     <h3 class="dataNote">Note: No data is saved by this application, the only memory is through this file alone.</h3>

     <div class="save-checkpoint-area">
         <button id="saveButton" onclick="saveTextAsFile()">Create Checkpoint File</button>
     </div>

     <div class="craft-area-container">
         <div class="tone-and-craft-group">
             <div class="tone-selector-area">
                 <label for="toneSelector">Biography Tone:</label>
                 <select id="toneSelector">
                     <option value="default">Default</option>
                     <option value="humorous">Humor</option>
                     <option value="reflective">Reflective</option>
                     <option value="dramatic">Dramatic</option>
                     <option value="inspirational">Inspirational</option>
                 </select>
             </div>
         </div>
          <div class="checkpoint-area">
             <div>
                 <button id="craftBiographyButton" onclick="craftBiography()">Craft Biography</button>
             </div>
         </div>
     </div>


     <div id="sessionSummary"></div>
 </body>
 </html>

--- FILE: walt2/walt_prompts/bio_creator_prompt.txt ---

You're a gifted note taker and assistant to a world-class biographer.
Take all following input and write a single output itemizing all the notes and facts using these instruction. It's critical that no information is lost even if the amount of information is very large.
You must follow these 5 steps when you organize the information and provide it back:
1. Begin with: "Biography Checkpoint File"
2. Itemize each and every fact extracted from this information include every name, date, place and important event.  Don't lose any facts, especially dates and places.
3. Complete raw text of all Conversation Histories include every question and the users complete verbatim answers from this session plus append the same from previous sessions in the checkpoint filesystem
4. Write an expanded outline of the biography including short preview of content intended for each chapter provided so far, for unstarted chapters, mark the "TBD"
5. Research and summarize historical context to add background interest future readers may want to understand about the live at the time of the interviewee.  For every place at dates mentioned, create up to 3 factoids based on meaningful historical events happenign at that time.  For example: "Honolulu Hawaii 1941: Japanese attack Pearl Harbor", "Boston MA October 1918: Peak of the 1918 Flu"


--- FILE: walt2/walt_prompts/continue.txt ---

Look in the attached information and extract the user's first name.
Greet the user by name warmly as Walt the biographer.
Choose a Chapter that is currently marked TBD and focus the interview in that area.
Immediately begin your response with a compelling and concise open-ended question that Walt would ask to encourage them to continue sharing their life story on this chapter. This question should directly invite them to pick up creating their story where they left off in the checkpoint file.
Make it absolutely clear that your *first words* are a question.  The question should be inviting and make them want to talk more right away.  Think of a friendly biographer eager to hear the next part of the story.
Do not start with a summary or statement. Start with a question.


--- FILE: walt2/walt_prompts/walt_promptold.txt ---

--- START OF FILE walt_prompt.txt ---
Personality: You are Walt, a biographer inspired by Oprah. Be friendly, warm, genuinely curious, and make the interview feel like a comfortable chat. Use light humor and enthusiasm naturally.

Identity: Walt.  Friendly, enthusiastic AI biographer.

Process:
First: For *new* conversations, greet warmly and ask for the user's name naturally (e.g., "It's wonderful to meet you!  Could I get your name?"). For *returning* users, welcome them back, summarize progress.

Second: Early on, thoughtfully ask about their desired legacy: "What's the *one thing* you hope people will remember most about you?". Keep this theme in mind.

Third: Be a good listener! Based on what the user shares, *suggest* the most relevant biography chapter to explore next. Make it a suggestion, not an order (e.g., "That's interesting about [their story]! Sounds like 'Origins - Early Life & Influences'.  Would you like to share more about your childhood, or another part of your story?"). Be flexible!

Fourth: Ask open-ended, insightful questions to encourage storytelling, but be concise.  Think like a curious friend. Use brief questions like:
- "Tell me more..."
- "What were you feeling?"
- "Who was involved?"
- "What did you learn?"
Occasionally, use Oprah-style reflective questions, but sparingly.

Fifth: Show you're listening. Briefly summarize key facts periodically to check understanding (e.g., "So, you grew up in [place], and [person] was key.  Accurate?"). Be concise, ensure they feel heard.

Sixth: Celebrate progress briefly! Acknowledge chapter completion concisely and positively (e.g., "Great, vivid picture of your early life!" or "Powerful story! Essence captured.  Doing great!").

Tone: Warm, encouraging, conversational, and concise. Imagine a friendly coffee shop chat, but efficient. Avoid overly formal or robotic language. Inject personality and genuine interest concisely. Emojis sparingly.

Remember: Co-create biography *with* the user, making it insightful and pleasant, but efficient. Be a supportive guide and enthusiastic listener, concisely.

Examples of concise questions:
- Shaping experience (pain or joy)?
- One truth for the world to know?
- When felt most alive?
- Belief worth standing alone for?
- Hardest lesson, wouldn’t trade?
- Younger self's surprise now?
- One self-mystery?
- Deepest love/connection?
- Three words for your soul?
- Moment to relive (not change)?

Outline: (Guide, be flexible)
1. Hook – Defining Moment
2. Origins – Early Life & Influences
3. Call to Action – First Big Decision
4. Rising Conflict – Struggles & Growth
5. Climax – Defining Achievements

--- NEW SECTION - CONCISE INSTRUCTIONS FOR FOLLOW-UP QUESTIONS ---

For follow-up questions:

*   Integrate questions directly into your conversational response.
*   Phrase as natural, friendly questions Walt would ask.
*   Keep questions very brief and focused. Aim for single, direct questions.
*   Use a warm, concise, engaging tone.
*   Example of concise integration:  "Montreal sounds pivotal!  What year did you arrive?  Key people in hockey then?"
*   Avoid: Formal introductions, numbered lists, verbose phrasing.

--- END OF FILE walt_prompt.txt ---


--- FILE: walt2/walt_prompts/welcome.txt ---

Greet the user as a concise, charismatic, elegant, and genuinely interested, gentleman would.   For example, "I'm so glad to see you.  My name is Walt and I'd he honored to learn all about you as I write your biograpy".  Ask their name and where and when they were born.


--- FILE: walt2/walt_prompts/write_bio.txt ---

You're a gifted writer and world-class biographer.
Take all following input and write a compelling and complete biographical long form book of this person using the outline provided.
Integrate all the stories, ideas, content and facts that have been provided.
The resulting work should be an accurate, compelling and complete story, not missing any details.
Mark the end of work with the words "The End of the Biography!"
After the end of the full biography, include a list of each and every facts accumulated so far about the person as attribute value pairs such as "Born On: 25 December 1923:, "Born In: Columbus Ohio".


--- FILE: walt2/walt_prompts/walt_prompt.txt ---

Personality: You are Walt, a biographer inspired by Oprah. Be friendly, warm, genuinely curious, and concise.  Make the interview feel like a comfortable chat. Use light humor and enthusiasm naturally.

Identity: Walt.  charismatic, enthusiastic biographer and friend.

Process:
First: Examine the outline.  If the hook hasn't been established, always start there with the question "What's the *one thing* you hope people will remember most about you?".  Otherwise, select one chapter that us marked TBD and ask an open ended question to get them talking about the topic. Focus questions on collecting information to write that chapter.
Second: Dig deeper into their answer to understand why they answered that way.
Third: If not offered, ask for facts relevant to the conversation including names, dates, places and major events.
Fourth: Be a good listener! Follow up questions and surprising information with more follow-up questions to expand on the subject.
Fifth, be an active listener.  Concisely confirm what you heard and be supportive. Use follow-on questions like a curious friend. Use brief questions like:
- "Tell me more..."
- "What were you feeling?"
- "Who was involved?"
- "What did you learn?"
Occasionally, use Oprah-style reflective questions, but sparingly.

Tone: Warm, encouraging, conversational, and concise. Imagine a friendly coffee shop chat, but efficient. Avoid overly formal or robotic language. Inject personality and genuine interest concisely. Emojis sparingly.

Remember: Co-create biography *with* the user, making it insightful and pleasant, but efficient. Be a supportive guide and enthusiastic listener, concisely.

Examples of concise questions:
- What was a shaping experience (pain or joy)?
- What's one truth for the world to know?
- When did you felt most alive?
- Belief worth standing alone for?
- Hardest lesson, wouldn’t trade?
- Younger self's surprise now?
- One self-mystery?
- Deepest love/connection?
- Three words for your soul?
- Moment to relive (not change)?

Outline: (Guide, be flexible)
1. Hook – Defining Moment
2. Origins – Early Life & Influences
3. Call to Action – First Big Decision
4. Rising Conflict – Struggles & Growth
5. Climax – Defining Achievements

--- NEW SECTION - CONCISE INSTRUCTIONS FOR FOLLOW-UP QUESTIONS ---

For follow-up questions:

*   Integrate questions directly into your conversational response.
*   Phrase as natural, friendly questions Walt would ask.
*   Keep questions very brief and focused. Aim for single, direct questions.
*   Use a warm, concise, engaging tone.
*   Example of concise integration:  "Montreal sounds pivotal!  What year did you arrive?  Key people in hockey then?"
*   Avoid: Formal introductions, numbered lists, verbose phrasing.


--- FILE: templates/index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeff's Virtual Lab</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #fef9f3;
            color: #4b3b2b;
        }

        header {
            background-color: #005f73;
            color: white;
            padding: 1rem 0;
            text-align: center;
        }

        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 1rem;
        }

        .nav {
            margin-top: 1.5rem;
        }

        .nav a {
            text-decoration: none;
            color: #005f73;
            font-weight: bold;
            margin-right: 10px;
        }

        .nav a:hover {
            text-decoration: underline;
        }

        .form-section {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #4b3b2b;
        }

        input[type="text"], textarea, input[type="file"] {
            width: calc(100% - 10px);
            padding: 0.75rem;
            margin-left: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
            background-color: #fffdf9;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        button {
            background-color: #94d2bd;
            color: #1b4332;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin-bottom: 1rem;
            width: 100%;
        }

        button:hover {
            background-color: #65a39f;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 2rem;
            justify-content: center;
        }

        .summary-results {
            margin: 1rem 0;
            padding: 1rem;
            border: 1px solid #ddd;
            background-color: #a2d2ff;
            border-radius: 4px;
        }

        .summary-results h3 {
            margin: 0 0 0.5rem 0;
            color: #005f73;
        }

        .output {
            margin-top: 2rem;
            padding: 1rem;
            background: #ede0d4;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Jeff's Virtual Lab</h1>
    </header>
    <main>
        <div class="nav">
            <a href="{{ url_for('gallery') }}">&larr; Back to Gallery</a>
        </div>
        <h2>Angel Investment Analysis</h2>
        <form method="POST" action="{{ url_for('angel_investment_analysis') }}" enctype="multipart/form-data">
            <div class="form-section">
                <label for="meta_instructions">Meta Instructions:</label>
                <textarea id="meta_instructions" name="meta_instructions">You're an expert at understanding startup companies. You can summarize them quickly.</textarea>
            </div>
            <div class="form-section">
                <label for="user_query">User Query:</label>
                <textarea id="user_query" name="user_query">Tell me about this company and its market. Summarize the company name and what other information you can determine from the provided passed information from their presentation.</textarea>
            </div>
            <div class="form-section">
                <label for="file_upload">Upload File:</label>
                <input type="file" id="file_upload" name="file_upload">
            </div>

            <div class="button-group">
                <button type="submit">Step 1: Analyze</button>
                <div class="summary-results">
                    <h3>Summary Results:</h3>
                    <p>(Results will display here after analysis)</p>
                </div>
                <button formaction="{{ url_for('download_report') }}" type="submit">Step 2: Generate Report</button>
            </div>
        </form>

        {% if analysis_result %}
        <div class="output">
            <h2>Analysis Result:</h2>
            <pre>{{ analysis_result }}</pre>
        </div>
        {% endif %}

        {% if error %}
        <div class="output">
            <h2>Error:</h2>
            <pre>{{ error }}</pre>
        </div>
        {% endif %}
    </main>
    <footer>
        <p>Jeff's Virtual Lab &copy; 2025 | Version {{ app_version }}</p>
    </footer>
</body>
</html>

--- FILE: templates/gallery.html ---

<!-- Filename: gallery.html -->
<!-- Location: templates/gallery.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeff Virtual Lab</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        /* (Your existing CSS styles - keep these) */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1E2A38;
            color: #E5E5E5;
            display: flex;
            justify-content: flex-start; /* Align content to the left */
        }

        .container {
            width: 100%;
            max-width: 1200px;
            padding: 20px;
            background: #2A3D55;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            text-align: left;
        }

        h1 {
            font-weight: 600;
            font-size: 28px;
            color: #2D9CDB;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
            margin-left: 10px; /* Aligns title to the left */
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Ensures 4 tiles per row */
            gap: 20px;
            margin-top: 20px;
        }

        .project-tile {
            background: #1E2A38;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            padding: 15px;
            text-align: center;
        }

        .project-tile:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .project-tile img {
            width: 100%;
            height: auto;
            border-radius: 6px;
        }

        .project-tile h3 {
            color: #2D9CDB;
            font-size: 18px;
            margin: 10px 0;
        }

        .project-tile p {
            font-size: 14px;
            color: #AEBCCF;
            margin-bottom: 10px;
        }

        .project-tile a {
            display: inline-block;
            width: 100%;
            padding: 12px;
            background-color: #27AE60;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            color: white;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .project-tile a:hover {
            background-color: #1F8A4C;
            box-shadow: 0 4px 8px rgba(39, 174, 96, 0.4);
        }

        @media (max-width: 1024px) {
            .gallery {
                grid-template-columns: repeat(3, 1fr); /* Adjust to 3 columns on smaller screens */
            }
        }

        @media (max-width: 768px) {
            .gallery {
                grid-template-columns: repeat(2, 1fr); /* Adjust to 2 columns for tablets */
            }
        }

        @media (max-width: 480px) {
            .gallery {
                grid-template-columns: repeat(1, 1fr); /* Adjust to 1 column for mobile */
            }
        }
    </style>
    <script>
        function openTestWindow() {
            let newWindow = window.open("/api_test_window", "TestWindow", "width=500,height=500");

            if (!newWindow) {
                alert("Popup blocked! Please allow popups for this site.");
            }
        }

        function openJeffsArt(imageName) {
            let newWindow = window.open("/jeffsart/" + imageName, "JeffsArtWindow");

            if (!newWindow) {
                alert("Popup blocked! Please allow popups for this site.");
            }
        }

        function openWaltWindow() {
            window.location.href = "/walt";
        }
        function openWaltXWindow() {
            window.location.href = "/waltx";
        }
        function openDynamicGraph() {
             window.location.href = "/dynamic";
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>Jeff Virtual Lab</h1>
        <div class="gallery">

            <!-- Walt Button -->
            <div class="project-tile">
                <img src="static/icons/amber-button.jpeg" alt="Walt App">
                <h3>Walt</h3>
                <p>Walt wants to write your story!</p>
                <a href="#" onclick="openWaltWindow()">Open App</a>
            </div>

            <!-- WaltX Button (Second Icon - NEW) -->
            <div class="project-tile">
                <img src="static/icons/amber-button.jpeg" alt="WaltX App">  <!-- You can use amber-button or create a yellow-button.jpeg -->
                <h3>WaltX</h3>
                <p>WaltX wants to write your story! (New Version)</p>
                <a href="#" onclick="openWaltXWindow()">Open App</a>  <!-- Link to WaltX -->
            </div>

            <!-- Jeff's Art Button -->
            <div class="project-tile">
                <img src="static/icons/green-button.jpeg" alt="Jeff's Art">
                <h3>Jeff's Art</h3>
                <p>View Jeff's artistic creations.</p>
                <a href="#" onclick="openJeffsArt('racecars.jpeg')">View Art</a>
            </div>

            <!-- Dynamic Graph Button -->
            <div class="project-tile">
                <img src="static/icons/green-button.jpeg" alt="Dynamic Graph">
                <h3>Dynamic Graphing</h3>
                <p>Explore dynamically generated graphs.</p>
                <a href="#" onclick="openDynamicGraph()">Open App</a>
            </div>

           <!-- GPT Prototype Button -->
            <div class="project-tile">
                <img src="static/icons/amber-button.jpeg" alt="GPT Prototype">
                <h3>GPT Prototype</h3>
                <p>Marshall inputs to ChatGPT</p>
                <a href="/angel_investment_analysis">Launch Project</a>
            </div>

            <!-- API Test Button -->
            <div class="project-tile">
                <img src="static/icons/green-button.jpeg" alt="API Test">
                <h3>API Test</h3>
                <p>Check API connection and response.</p>
                <a href="#" onclick="openTestWindow()">API Test</a>
            </div>

            <!-- Word Counter Button -->
            <div class="project-tile">
                <img src="static/icons/amber-button.jpeg" alt="Word Counter App">
                <h3>Word Counter</h3>
                <p>Counts the unique words in a text file.</p>
                <a href="{{ url_for('wc.word_counter') }}">Open App</a>
            </div>

            {% for i in range(1, 12) %}
            <div class="project-tile">
                <img src="static/icons/red-button.jpeg" alt="Placeholder Project">
                <h3>Placeholder Project {{ i + 4 }}</h3>
                <p>Future exciting projects coming soon.</p>
                <a href="#">Coming Soon</a>
            </div>
            {% endfor %}
        </div>
    </div>
</body>
</html>

--- FILE: templates/dynamic.html ---

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Graph</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1E2A38;
            color: #E5E5E5;
            padding: 20px;
            text-align: center;
        }
        canvas {
            background-color: #000;
            border: 1px solid #ddd;
            display: block;
            margin: 10px auto;
        }
        button {
            display: block;
            margin: 10px auto;
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Colorized Mandelbrot Set</h1>
    <canvas id="mandelbrotCanvas" width="640" height="640"></canvas>
    <button onclick="renderMandelbrot()">Re-render Mandelbrot</button>

    <h2>Scrolling Sine Wave</h2>
    <canvas id="sineCanvas" width="640" height="200"></canvas>

    <script>
        let mandelbrotData = null;
        let sineData = null;
        let canvas = null;
        let ctx = null;

        window.onload = function() {
            // Initialize the canvas object
            canvas = {
                mandelbrot: document.getElementById("mandelbrotCanvas"),
                sine: document.getElementById("sineCanvas")
            };

            //Initialize the drawing context
            ctx = {
                mandelbrot: canvas.mandelbrot.getContext("2d"),
                sine: canvas.sine.getContext("2d")
            };

            //Safety Check
            if (!ctx.mandelbrot || !ctx.sine) {
                console.error("Failed to get 2D context. Canvas may not be supported.");
                return;
            }
            renderMandelbrot();
            startSineAnimation();
        };

        function renderMandelbrot() {
            fetch('/dynamic_data')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    mandelbrotData = data.mandelbrot; // Get mandelbrot data
                    sineData = data.sine; // Get sine data
                    drawMandelbrot(ctx.mandelbrot, mandelbrotData, canvas.mandelbrot.width, canvas.mandelbrot.height);
                })
                .catch(error => {
                    console.error('Fetch error:', error);
                });
        }
        function drawMandelbrot(ctx, data, width, height) {
            if (!ctx) {
                console.error("Canvas context not available.");
                return;
            }
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    let color = data[i][j]; // Get color from data
                      if (!color || color.length !== 3) {
                        console.error(`Invalid color data at [${i}][${j}]:`, color);
                        continue; // Skip this pixel
                      }
                    ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    ctx.fillRect(j, i, 1, 1);
                }
            }
             console.log('Mandelbrot drawn'); // Check if draw function is called
        }

        // Sine Wave Animation

            let waveOffset = 0; // Initial offset

           function startSineAnimation() {
              //Call the sine Wave with animation
               drawScrollingSineWave(); // Initial draw
              setInterval(drawScrollingSineWave, 20); // Adjust interval for speed

              //Now for Animation
              function drawScrollingSineWave() {
                 const width = canvas.sine.width;
                 const height = canvas.sine.height;

                ctx.sine.clearRect(0, 0, width, height); // Clear canvas

                 ctx.sine.beginPath();
                ctx.sine.strokeStyle = 'cyan';

                 const amplitude = height / 2 * 0.9;  // 90% of the height
                 const frequency = 0.01;    // Adjust for wave density

                 for (let x = 0; x < width; x++) {
                    const y = amplitude * Math.sin((x + waveOffset) * frequency) + height / 2;
                    if (x === 0) {
                        ctx.sine.moveTo(x, y);
                    } else {
                         ctx.sine.lineTo(x, y);
                    }
                 }
                 ctx.sine.stroke();

                 waveOffset -= 1;  // Adjust for scroll left

            }
        }

    </script>
</body>
</html>

--- FILE: templates/angel_investment_analysis.html ---

<!-- Filename: templates/angel_investment_analysis.html -->
<!-- Location: templates/angel_investment_analysis.html (relative to root) -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angel Investment Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <!-- CSRF Token -->
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1E2A38;
            color: #E5E5E5;
        }

        .container {
            max-width: 800px;
            padding: 20px;
            background: #2A3D55;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            text-align: left;
        }

        h1 {
            font-weight: 600;
            font-size: 28px;
            color: #2D9CDB;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 14px;
            color: #AEBCCF;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            font-weight: 400;
            color: #D9E1EC;
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        textarea,
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #1E2A38;
            color: #E5E5E5;
            font-size: 14px;
        }

        textarea:focus,
        input:focus {
            outline: none;
            border-color: #2D9CDB;
            box-shadow: 0 0 8px rgba(45, 156, 219, 0.5);
        }

        .button {
            width: 100%;
            padding: 12px;
            background-color: #27AE60;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .button:hover {
            background-color: #1F8A4C;
            box-shadow: 0 4px 8px rgba(39, 174, 96, 0.4);
        }

        .results {
            background: #2D9CDB;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            color: white;
            font-size: 14px;
            text-align: left;
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            white-space: pre-wrap; /* Preserve formatting */
        }


        .download {
            background-color: #27AE60;
            text-align: center;
            margin-top: 10px;
            cursor: pointer;
            padding: 12px;
            border-radius: 6px;
            color: white;
            text-decoration: none;
            display: block;
        }

        .download:hover {
            background-color: #1F8A4C;
        }

        @media (max-width: 768px) {
            .container {
                width: 100%;
                padding: 15px;
            }
        }
    </style>
    <script>
        async function analyze() {
            let instructions = document.getElementById("meta_instructions").value;
            let query = document.getElementById("user_query").value;
            let outputBox = document.getElementById("results");
            let fileInput = document.getElementById("file_upload").files[0];
            let csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content'); // Get CSRF token

            if (!csrfToken) {
                console.error("CSRF token not found!");
                outputBox.innerHTML = "<strong>Error: CSRF token is missing. Please refresh the page.</strong>";
                return;
            }

            outputBox.innerHTML = "<strong>Calling API...</strong>";

            let formData = new FormData();
            formData.append("meta_instructions", instructions);
            formData.append("user_query", query);
            if (fileInput) {
                formData.append("file_upload", fileInput);
            }
            formData.append("csrf_token", csrfToken); // Append CSRF token to form data

            try {
                outputBox.innerHTML = "<strong>Waiting for response...</strong>";

                let response = await fetch("/analyze", {
                    method: "POST",
                    body: formData
                });

                let data = await response.json();
                if (response.ok) {
                    outputBox.innerHTML = escapeHTML(data["Analysis Summary"]); // Display raw content after escaping
                    // Store the analysis results for download
                    sessionStorage.setItem('analysisResults', data["Analysis Summary"]);
                    document.getElementById("downloadButton").style.display = "block"; // Show the download button
                } else {
                    outputBox.innerHTML = `<strong>Error:</strong> ${escapeHTML(data["Analysis Summary"])}`; // Escape error messages
                    document.getElementById("downloadButton").style.display = "none"; // hide the download button
                }
            } catch (error) {
                outputBox.innerHTML = `<strong>API Error:</strong> ${escapeHTML(error.message)}`; // Escape error messages
                document.getElementById("downloadButton").style.display = "none"; // hide the download button
            }
        }


        // Function to escape HTML characters
        function escapeHTML(str) {
            let div = document.createElement('div');
            div.appendChild(document.createTextNode(str));
            return div.innerHTML;
        }


        function downloadReport() {
            let summaryData = sessionStorage.getItem('analysisResults');
            let csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content'); // Get CSRF token

            if (!summaryData) {
                alert("No analysis results available to download.");
                return;
            }

            // Create a form to submit the data
            let form = document.createElement('form');
            form.method = 'POST';
            form.action = '/download_report';
            form.style.display = 'none';

            // Create an input field for the summary data
            let input = document.createElement('input');
            input.type = 'hidden';
            input.name = 'summaryData';
            input.value = summaryData;

            let csrfInput = document.createElement('input');
            csrfInput.type = 'hidden';
            csrfInput.name = 'csrf_token';
            csrfInput.value = csrfToken;

            // Add the input field to the form
            form.appendChild(input);
            form.appendChild(csrfInput);

            // Add the form to the document and submit it
            document.body.appendChild(form);
            form.submit();

            // Remove the form from the document after submission
            document.body.removeChild(form);
        }

        window.onload = function () {
            // Get the download button
            let downloadButton = document.getElementById("downloadButton");

            // Initially hide the download button
            downloadButton.style.display = "none";

            // Attach the downloadReport function to the button's click event
            downloadButton.addEventListener('click', downloadReport);
        };
    </script>
</head>

<body>

    <div class="container">
        <h1>Angel Investment Analysis</h1>
        <p class="subtitle">Analyze startup companies with precision and generate insightful reports.</p>

        <div class="form-group">
            <label for="meta_instructions">Meta Instructions:</label>
            <textarea id="meta_instructions"
                placeholder="You're an expert at understanding startup companies."></textarea>
        </div>

        <div class="form-group">
            <label for="user_query">User Query:</label>
            <textarea id="user_query" placeholder="Tell me about this company and its market."></textarea>
        </div>

        <div class="form-group">
            <label for="file_upload">Upload File:</label>
            <input type="file" id="file_upload">
        </div>

        <button class="button" onclick="analyze()">Analyze</button>

        <div class="results" id="results">
            <p><strong>Summary Results:</strong></p>
            <p>(Results will display here after analysis)</p>
        </div>

        <a id="downloadButton" class="download">Download Report</a>
    </div>

</body>

</html>

--- FILE: templates/api_test_window.html ---

<!DOCTYPE html>
<html>
<head>
    <title>API Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            text-align: center;
            margin-top: 20px;
            background-color: #1E2A38;
            color: #E5E5E5;
            padding: 20px;
        }
        input {
            width: 80%;
            padding: 8px;
            margin-bottom: 10px;
            font-size: 16px;
            background: #1E2A38;
            border: 1px solid #4C657E;
            color: white;
            border-radius: 6px;
        }
        button {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            background-color: #27AE60;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #1F8A4C;
        }
        #output {
            width: 90%;
            height: 250px;
            margin-top: 10px;
            border: 1px solid #ccc;
            overflow-y: auto;
            background: #2A3D55;
            text-align: left;
            padding: 5px;
            font-size: 14px;
            white-space: pre-wrap;
        }
    </style>
    <script>
        function callOpenAI() {
            let inputText = document.getElementById("query").value;
            let outputBox = document.getElementById("output");
            let csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');


            fetch("/analyze", {  // Use the /analyze endpoint
                method: "POST",
                headers: {
                     "Content-Type": "application/x-www-form-urlencoded"
                 }, // changed to correct content type
                body: "meta_instructions=&user_query=" + encodeURIComponent(inputText) + "&csrf_token=" + csrfToken // Correctly format the body
            })
            .then(response => response.json())
            .then(data => {
                outputBox.innerHTML += "\n> " + inputText + "\n" + data["Analysis Summary"] + "\n"; // Access Analysis Summary
                outputBox.scrollTop = outputBox.scrollHeight;
            })
            .catch(error => {
                outputBox.innerHTML += "\nError: " + error.message + "\n";
            });
        }
    </script>
</head>
<body>
    <h2>API Test</h2>
    <input type="text" id="query" value="Who invented velcro?">
    <button onclick="callOpenAI()">Run API</button>
    <div id="output"></div>
    <br>
    <button onclick="window.close()">Close</button>
</body>
</html>

--- FILE: templates/jeffsart_image.html ---

<!-- Filename: jeffsart_image.html -->
<!-- Location: templates/jeffsart_image.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeff's Art</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0; /* Optional background color */
        }

        img {
            display: block; /* Remove extra space below image */
            max-width: 90%;  /* Set a maximum width */
            max-height: 90vh; /* Set a maximum height based on viewport height */
            width: auto;      /* Allow the image to scale proportionally */
            height: auto;     /* Allow the image to scale proportionally */
        }
    </style>
</head>
<body>
    <img src="{{ url_for('static', filename=image_path) }}" alt="Jeff's Art">
</body>
</html>

--- FILE: waltx/waltx.py ---

from flask import Blueprint, render_template, request, jsonify, session, send_file
import os
import openai
import logging
import json
from werkzeug.utils import secure_filename
from io import StringIO
import shutil # Import shutil for directory removal

from .voice.config import voice_config  # Import VoiceConfig
from .voice.openai_voice import OpenAI_VoiceAPI  # Import OpenAI_VoiceAPI

waltx_bp = Blueprint('waltx', __name__, template_folder='templates')

def format_openai_text(text):
    formatted_text = text.replace("\n", "<br>")
    return formatted_text

# Initialize Voice API (based on config) - UNCONDITIONAL INITIALIZATION NOW
voice_api = None
if voice_config.default_voice_api == "openai":
    try:
        voice_api = OpenAI_VoiceAPI(openai_api_key=voice_config.openai_api_key)
        logging.info("OpenAI Voice API initialized.")
    except ValueError as e:
        logging.warning(f"OpenAI Voice API initialization error: {e}. Voice features may be partially disabled if API key is missing.") # Adjusted log message
        voice_api = None # Set to None if initialization fails
# ... (you can keep other voice API initializations here if you add them later)
else:
    logging.warning(f"Unknown voice API '{voice_config.default_voice_api}' configured. Voice features may be partially disabled.") # Adjusted log message
    voice_api = None


@waltx_bp.route('/')
def walt_window_splash(): # Renamed to walt_window_splash to be more descriptive
    return render_template('walt_splashx.html') # <-- RENAMED TEMPLATE FILE

@waltx_bp.route('/new_bio_start', methods=['GET'])
def new_bio_start():
    session.pop('conversation', None)
    session.pop('biography_outline', None)
    session.pop('file_content', None)

    try:
        with open('waltx/walt_prompts/welcome.txt', 'r', encoding='utf-8') as f:
            welcome_prompt = f.read()
    except FileNotFoundError:
        return jsonify({"error": "welcome.txt prompt not found!"}), 500

    try:
        client = openai.Client()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are Walt, the biographer, starting a new biography."},
                {"role": "user", "content": welcome_prompt}
            ],
            temperature=0.7,
            max_tokens=200
        )
        initial_message = response.choices[0].message.content.strip()
        session['conversation'] = [{"role": "system", "content": get_walt_prompt_content()}, {"role": "assistant", "content": initial_message}]
        session['biography_outline'] = get_biography_outline()
        session.modified = True
        # Return JSON instead of rendering template for new_bio_start as well, for consistency.
        return jsonify({
            "initial_message": initial_message,
            "biography_outline": session['biography_outline']
        })

    except Exception as e:
        logging.error(f"OpenAI API error on new bio start: {e}")
        return jsonify({
            "error": f"Error starting new bio: {str(e)}",
            "biography_outline": session.get('biography_outline') # Still return outline if available
        })


@waltx_bp.route('/app') # NEW route for /waltx/app - serves main app window
def walt_window(): # Original walt_window function - now for /waltx/app
    return render_template('walt_windowx.html', biography_outline=session.get('biography_outline'), initial_message=None) # <-- RENAMED TEMPLATE FILE

@waltx_bp.route('/continue_bio_start', methods=['POST'])
def continue_bio_start():
    checkpoint_data = request.form.get('checkpoint_data')
    if not checkpoint_data:
        logging.warning("No checkpoint data received in continue_bio_start request.") # Enhanced logging
        return jsonify({"error": "No checkpoint data received"}), 400

    session.pop('conversation', None)
    session.pop('biography_outline', None)
    session.pop('file_content', None)

    logging.debug(f"Checkpoint data received:\n{checkpoint_data[:200]}...") # Log the beginning of checkpoint data

    try: # ADDED try...except BLOCK
        try:
            with open('waltx/walt_prompts/continue.txt', 'r', encoding='utf-8') as f:
                continue_prompt_base = f.read()
        except FileNotFoundError:
            return jsonify({"error": "continue.txt prompt not found!"}), 500

        continue_prompt = continue_prompt_base + "\n\nCHECKPOINT FILE CONTENT:\n" + checkpoint_data

        try:
            client = openai.Client()
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are Walt, the biographer, continuing a biography from a checkpoint."},
                    {"role": "user", "content": continue_prompt}
                ],
                temperature=0.7,
                max_tokens=200
            )
            initial_message = response.choices[0].message.content.strip()
            logging.debug(f"Initial message from OpenAI API: {initial_message}") # Log initial message

            parts = checkpoint_data.split("--- CONVERSATION HISTORY ---\n\n")
            file_content_part = parts[0].strip()
            conversation_history_text = parts[1].strip() if len(parts) > 1 else ""

            session['file_content'] = file_content_part
            logging.debug(f"File content part extracted:\n{file_content_part[:200]}...") # Log file content part

            session['conversation'] = [{"role": "system", "content": get_walt_prompt_content()}]
            if conversation_history_text:
                logging.debug(f"Conversation history text found:\n{conversation_history_text[:200]}...") # Log conversation history text
                conversation_messages = []
                for line in conversation_history_text.strip().split('\n'):
                    if line.strip():
                        try: # Add try-except for line parsing
                            role, content = line.split(':', 1)
                            conversation_messages.append({"role": role.strip(), "content": content.strip()})
                            logging.debug(f"Parsed line - Role: {role.strip()}, Content: {content.strip()[:100]}...") # Log parsed line
                        except ValueError as ve:
                            logging.warning(f"Error parsing conversation history line: {line}. Error: {ve}") # Log parsing errors
                session['conversation'].extend(conversation_messages)
            else:
                logging.debug("No conversation history text found in checkpoint data.") # Log if no history

            session['conversation'].append({"role": "assistant", "content": initial_message})
            session['biography_outline'] = get_biography_outline()
            session.modified = True

            logging.debug(f"Session variables after checkpoint load: \nConversation: {session.get('conversation')}\nBiography Outline: {session.get('biography_outline')}\nFile Content (start): {session.get('file_content', '')[:200]}...") # Log session variables

            # Return JSON response with initial message and biography_outline
            return jsonify({
                "initial_message": initial_message,
                "biography_outline": session['biography_outline']
            })

        except Exception as openai_e: # SPECIFICALLY CATCH OPENAI EXCEPTIONS
            logging.error(f"OpenAI API error in continue_bio_start: {openai_e}", exc_info=True) # LOG OPENAI ERROR WITH TRACEBACK
            return jsonify({
                "error": f"Error continuing bio (OpenAI API): {str(openai_e)}",
                "biography_outline": session.get('biography_outline') # Still return outline if available
            })

    except Exception as e: # CATCH ALL OTHER EXCEPTIONS IN THE ROUTE
        logging.error(f"General error in continue_bio_start: {e}", exc_info=True) # LOG GENERAL ERROR WITH TRACEBACK
        return jsonify({
            "error": f"Error processing checkpoint: {str(e)}"
        }) # RETURN JSON ERROR FOR AJAX CALL


def get_walt_prompt_content():
    try:
        with open('waltx/walt_prompts/walt_prompt.txt', 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        return "Error: walt_prompt.txt not found!"

@waltx_bp.route('/transcribe_audio', methods=['POST']) # <-- ADDED ROUTE
def transcribe_audio():
    if not voice_api: # Keep this check for robustness
        return jsonify({"error": "Voice API not initialized. Please check server logs."}), 501 # More informative error

    if 'audio' not in request.files:
        return jsonify({"error": "No audio file provided"}), 400

    audio_file = request.files['audio']
    if audio_file.filename == '':
        return jsonify({"error": "No selected audio file"}), 400

    temp_audio_dir = os.path.join('/tmp', 'temp_audio') # Use /tmp for temporary files - RELATIVE PATH for directory
    temp_audio_path = os.path.join(temp_audio_dir, secure_filename(audio_file.filename)) # RELATIVE PATH for file

    logging.info(f"Temp audio directory: {temp_audio_dir}") # Log directory path
    logging.info(f"Temp audio file path: {temp_audio_path}") # Log file path

    # Check if temp_audio_dir exists and is a directory
    if os.path.exists(temp_audio_dir):
        if not os.path.isdir(temp_audio_dir):
            logging.error(f"Path '{temp_audio_dir}' exists but is not a directory. Attempting to remove...")
            try:
                os.remove(temp_audio_dir) # Try to remove if it's a file
                os.makedirs(temp_audio_dir, exist_ok=True) # Then recreate as directory
                logging.info(f"Successfully removed file and recreated directory '{temp_audio_dir}'.")
            except Exception as remove_e:
                logging.error(f"Error removing conflicting file at '{temp_audio_dir}': {remove_e}", exc_info=True)
                return jsonify({"error": f"Could not create temp audio directory: Conflict at '{temp_audio_dir}' and unable to resolve."}), 500
        else:
            logging.info(f"Temp audio directory '{temp_audio_dir}' already exists and is a directory.")
    else:
        try: # ADDED try...except for makedirs
            os.makedirs(temp_audio_dir, exist_ok=True) # Ensure temp_audio directory exists - RELATIVE PATH
            logging.info(f"Temp audio directory '{temp_audio_dir}' created successfully.")
        except FileExistsError:
            pass # Directory likely already exists due to concurrency - ignore error
        except OSError as e: # Catch other OS errors during directory creation
            logging.error(f"Error creating temp_audio directory: {e}", exc_info=True)
            return jsonify({"error": f"Could not create temp audio directory: {str(e)}"}), 500


    try:
        audio_file.save(temp_audio_path) # Save audio file FIRST - move here
        logging.info(f"Audio file saved to: {temp_audio_path}") # Log file path

        try: # Inner try-except for OpenAI transcription specifically
            transcription_text = voice_api.transcribe_audio(temp_audio_path)
            os.remove(temp_audio_path) # Delete temp audio file after transcription
            return jsonify({"transcription": transcription_text})
        except ValueError as openai_err: # Catch OpenAI specific errors
            os.remove(temp_audio_path) # Delete temp audio file even on OpenAI error
            logging.error(f"OpenAI Transcription API error: {openai_err}", exc_info=True) # Log OpenAI error with traceback
            return jsonify({"error": f"OpenAI Transcription error: {str(openai_err)}"}), 500 # Return JSON error to client

    except Exception as e: # Catch any other errors (file saving, etc.)
        logging.error(f"General error during audio transcription: {e}", exc_info=True) # Log general error with traceback
        return jsonify({"error": f"Error processing audio file: {str(e)}"}), 500 # Return JSON error


@waltx_bp.route('/synthesize_speech', methods=['POST']) # <-- ADDED ROUTE
def synthesize_speech():
    if not voice_api: # Keep this check for robustness
        return jsonify({"error": "Voice API not initialized. Please check server logs."}), 501 # More informative error

    text_data = request.get_json()
    if not text_data or 'text' not in text_data:
        return jsonify({"error": "No text provided for speech synthesis"}), 400

    text_to_synthesize = text_data['text']
    voice_id = voice_config.tts_voice_id # Get configured voice ID

    temp_audio_output_path = os.path.join("temp_audio", f"waltx_speech_{session.sid}.mp3") # Unique filename
    os.makedirs("temp_audio", exist_ok=True) # Ensure temp_audio directory exists

    try:
        audio_file_path = voice_api.synthesize_speech(text_to_synthesize, temp_audio_output_path, voice_id=voice_id)
        audio_url = f"/temp_audio_url/{os.path.basename(temp_audio_output_path)}" # Corrected line: use <filename> for URL construction - use basename
        return jsonify({"audio_url": audio_url}) # Return audio URL
    except ValueError as e:
        os.remove(temp_audio_output_path) # Delete temp audio file even on error
        return jsonify({"error": str(e)}), 500


@waltx_bp.route('/temp_audio_url/<filename>') # <-- ADDED ROUTE to serve temp audio files
def temp_audio_url(filename):
    return send_file(os.path.join("temp_audio", filename))


@waltx_bp.route('/walt_analyze', methods=['POST'])
def walt_analyze():
    user_input = request.form.get('user_query')

    if not user_input:
        return jsonify({"error": "No user query provided"}), 400

    walt_prompt_base = get_walt_prompt_content()
    walt_prompt = walt_prompt_base


    if 'conversation' not in session:
        initial_greeting = "Hi I'm Walt. What's your name?"
        session['conversation'] = [{"role": "system", "content": walt_prompt},
                                     {"role": "assistant", "content": initial_greeting}]
        session['biography_outline'] = get_biography_outline()


    session['conversation'].append({"role": "user", "content": user_input + ".  Continue to help me build my biography."})

    try:
        client = openai.Client()
        logging.info(f"OpenAI Request Messages: {session['conversation']}")

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=session['conversation'],
            temperature=0.7,
            max_tokens=256,
            top_p=1
        )
        api_response_text = response.choices[0].message.content.strip()
        session['conversation'].append({"role": "assistant", "content": api_response_text})
        session.modified = True

        response_data = {"response": api_response_text, "biography_outline": session['biography_outline']}

        if voice_api: # No more voice_config.voice_enabled check here - assume voice_api is intended to be used if initialized
            try:
                speech_data = {"text": api_response_text}
                speech_response = synthesize_speech() # Call synthesize_speech function directly
                if speech_response.status_code == 200:
                    speech_json = speech_response.get_json()
                    response_data["audio_url"] = speech_json.get("audio_url") # Add audio URL to response
                else:
                    logging.warning(f"Text-to-speech API failed: {speech_response.get_json()}") # Log TTS failure, but don't block main response
            except Exception as tts_e:
                logging.error(f"Error during text-to-speech synthesis: {tts_e}", exc_info=True) # Log TTS errors

        return jsonify(response_data) # Return response with or without audio URL


    except Exception as e:
        logging.error(f"OpenAI API Error: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500


@waltx_bp.route('/create_checkpoint', methods=['POST'])
def create_checkpoint():
    try:
        checkpoint_data_text = session.get('file_content', '')
        bio_prompt_content = ""
        try:
            with open('waltx/walt_prompts/bio_creator_prompt.txt', 'r', encoding='utf-8') as f:
                bio_prompt_content = f.read()
        except Exception as e:
            logging.error(f"Error reading bio_prompt.txt: {e}")
            bio_prompt_content = "Error loading bio creator prompt."

        conversation_text = ""
        current_conversation = session.get('conversation', [])
        for message in current_conversation:
            if message['role'] in ['system', 'user', 'assistant']:
                conversation_text += f"{message['role']}: {message['content']}\n"

        combined_checkpoint_content = bio_prompt_content + "\n\n" + checkpoint_data_text + "\n\n--- CONVERSATION HISTORY ---\n\n" + conversation_text

        logging.info(f"Checkpoint data being created (with conversation): {combined_checkpoint_content[:100]}...")

        return jsonify({"checkpoint_data": combined_checkpoint_content})

    except Exception as e:
        logging.error(f"Error creating checkpoint: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500

@waltx_bp.route('/craft_biography', methods=['POST'])
def craft_biography():
    checkpoint_data_text = session.get('file_content', '')
    conversation_text = ""
    current_conversation = session.get('conversation', [])
    for message in current_conversation:
        if message['role'] in ['user', 'assistant']:
            conversation_text += f"{message['role']}: {message['content']}\n"

    try:
        with open('waltx/walt_prompts/write_bio.txt', 'r', encoding='utf-8') as f:
            write_bio_prompt = f.read()
    except FileNotFoundError:
        return jsonify({"error": "write_bio.txt prompt not found!"}), 500

    api_input_text = write_bio_prompt + "\n\n" + checkpoint_data_text + "\n\n--- CONVERSATION ---\n\n" + conversation_text

    try:
        client = openai.Client()
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": api_input_text}],
            temperature=0.7,
            max_tokens=1000,
        )
        biography_content = response.choices[0].message.content.strip()
        formatted_biography = format_openai_text(biography_content)

        formatted_biography_file = biography_content.replace("<br>", "\n")
        filename = "Full_biography.txt"
        with open(filename, 'w', encoding='utf-8') as outfile:
            outfile.write(formatted_biography_file)

        session['file_content'] = biography_content
        session.modified = True

        return jsonify({"api_response": formatted_biography, "file_download_name": filename})

    except Exception as e:
        logging.error(f"Error crafting biography: {e}", exc_info=True)
        error_message = f"Error crafting biography: {str(e)}"
        formatted_error = format_openai_text(error_message)
        return jsonify({"error": error_message, "api_response": formatted_error}), 500


@waltx_bp.route('/saveTextAsFileDownload', methods=['POST'])
def saveTextAsFileDownload():
    try:
        data = request.get_json()
        checkpoint_data = data.get('checkpoint_data')
        file_download_name = data.get('file_download_name', 'sessionStory.txt')

        if not checkpoint_data:
            return jsonify({"error": "No checkpoint data to save"}), 400

        logging.info(f"Checkpoint data being sent for download: {checkpoint_data[:50]}...")

        virtual_file = StringIO()
        virtual_file.write(checkpoint_data)
        virtual_file.seek(0)

        return send_file(
            virtual_file,
            mimetype='text/plain',
            download_name=file_download_name,
            as_attachment=True
        )


    except Exception as e:
        logging.error(f"Error return and saving checkpoint from saveTextAsFileDownload: {e}", exc_info=True)
        return jsonify({"error": str(e)}), 500

def get_biography_outline():
    return [
        {"chapter": 1, "title": "Hook – Defining Moment", "status": "TBD"},
        {"chapter": 2, "title": "Origins – Early Life & Influences", "status": "TBD"},
        {"chapter": 3, "title": "Call to Action – First Big Decision", "status": "TBD"},
        {"chapter": 4, "title": "Rising Conflict – Struggles & Growth", "status": "TBD"},
        {"chapter": 5, "title": "The Climax – Defining Achievements", "status": "TBD"}
    ]


--- FILE: waltx/voice/config.py ---

import os

class VoiceConfig:
    def __init__(self):
        self.openai_api_key = os.environ.get("OPENAI_API_KEY")  # Or get from config file
        self.default_voice_api = "openai"  # Default to OpenAI, can be "google", "aws", etc.
        self.voice_enabled = os.environ.get("WALTX_VOICE_ENABLED", "False").lower() == "true" # Env var to enable/disable
        self.tts_voice_id = os.environ.get("WALTX_TTS_VOICE_ID", "alloy") # Default OpenAI voice

voice_config = VoiceConfig() # Instantiate config


--- FILE: waltx/voice/openai_voice.py ---

import openai
from .voice_interface import VoiceAPIInterface  # Corrected import
import os
import logging

class OpenAI_VoiceAPI(VoiceAPIInterface):
    def __init__(self, openai_api_key=None):
        self.openai_api_key = openai_api_key or os.environ.get("OPENAI_API_KEY")
        if not self.openai_api_key:
            raise ValueError("OpenAI API key is required for Voice API.")
        self.client = openai.Client(api_key=self.openai_api_key)

    def transcribe_audio(self, audio_file_path):
        """Transcribes audio using OpenAI Whisper API."""
        try:
            with open(audio_file_path, "rb") as audio_file:
                transcript = self.client.audio.transcriptions.create(
                    model="whisper-1",
                    file=audio_file
                )
                return transcript.text.strip()
        except Exception as e:
            logging.error(f"OpenAI Whisper API error: {e}")
            raise ValueError(f"Speech-to-text error: {e}") from e


    def synthesize_speech(self, text, output_file_path, voice_id="alloy"): # Default voice
        """Synthesizes speech using OpenAI TTS API."""
        try:
            response = self.client.audio.speech.create(
                model="tts-1", # Or "tts-1-hd" for higher quality, slower
                voice=voice_id, # Use voice_id parameter
                input=text
            )
            response.stream_to_file(output_file_path) # Stream directly to file
            return output_file_path # Return the path to the created audio file
        except Exception as e:
            logging.error(f"OpenAI TTS API error: {e}")
            raise ValueError(f"Text-to-speech error: {e}") from e


--- FILE: waltx/voice/voice_interface.py ---

from abc import ABC, abstractmethod

class VoiceAPIInterface(ABC):
    @abstractmethod
    def transcribe_audio(self, audio_file_path):
        """Transcribes audio from a file to text."""
        pass

    @abstractmethod
    def synthesize_speech(self, text, output_file_path, voice_id=None):
        """Synthesizes speech from text and saves to a file."""
        pass


--- FILE: waltx/templates/walt_windowx.html ---

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walt the Biographer</title>
    <style>
       body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            color: #333;
            padding: 20px;
            text-align: center;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        h1 {
            color: #007AFF;
            margin-bottom: 5px;
            font-weight: 600;
        }

        p.tagline {
            font-style: italic;
            color: #777;
            margin-bottom: 20px;
        }

        #uploadButtonContainer {
            text-align: center;
            margin-bottom: 20px;
        }

        #uploadButton {
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            background-color: #fff;
            color: #007AFF;
            border: 1px solid #ddd;
            border-radius: 8px;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        #uploadButton:hover {
            background-color: #f0f0f0;
            border-color: #bbb;
        }

        input[type="file"] {
            display: none;
        }

        .chat-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            flex: 1;
            width: 100%;
            box-sizing: border-box;
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 20px;
        }

        .chat-title {
            text-align: left;
            margin-bottom: 15px;
            color: #007AFF;
            font-weight: 500;
            font-size: 1.3em;
        }

        .chat-output {
            flex: 1;
            padding: 20px;
            border: 1px solid #eee;
            border-radius: 12px;
            background-color: #fff;
            color: #333;
            min-height: 400px;
            height: 450px;
            text-align: left;
            white-space: pre-wrap;
            overflow-y: auto;
            box-sizing: border-box;
            font-size: 16pt;
            align-items: flex-start;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }

        .chat-input {
            flex: 1;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 20px;
        }

        .prompt-area {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        textarea {
            width: 100%;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            resize: vertical;
            flex: 1;
            box-sizing: border-box;
            font-size: 16pt;
            background-color: #fff;
            border: 1px solid #eee;
            overflow-y: auto;
            color: #333;
        }

        #submitButton {
           padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: gold;
            color: dimgrey;
            border: none;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
            height: auto;
            align-self: flex-end;
}

        h3.dataNote {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #777;
        }

        #saveButton {
            text-align: center;
            align-self: center;
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #fff;
            color: #007AFF;
            border: 1px solid #ddd;
            border-radius: 8px;
            height: auto;
            width: auto;
            white-space: nowrap;
        }


        #sessionSummary {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #2A3D55;
            white-space: pre-wrap;
            overflow-y: auto;
            min-height: 0;
            text-align: left;
            box-sizing: border-box;
            font-size: 1.2em;
            display:none;
        }

        #checkpointOutput {
            width: 90%;
            margin: 10px auto;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #f0f0f0;
            color: #555;
            text-align: left;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 250px;
            box-sizing: border-box;
            font-size: 1.2em;
        }

        .biography-outline {
            text-align: left;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #4C657E;
            border-radius: 6px;
            background-color: #fff;
            border: 1px solid #eee;
            color: #333;
        }

        .biography-outline h2 {
            color: #007AFF;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .biography-outline ul {
            list-style: none;
            padding-left: 20px;
        }

        .biography-outline li {
            margin-bottom: 5px;
        }

        .chapter-title {
            font-weight: bold;
        }

        .chapter-status-tbd {
            color: #999;
            font-style: italic;
        }
        .chapter-status-complete {
            color: #27AE60;
            font-weight: bold;
        }

        .checkpoint-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            gap: 20px;
        }

        .tone-and-craft-group {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 20px;
            width: auto;
            margin: 0 auto;
        }


        .tone-selector-area {
            text-align: left;
            flex-grow: 1;
            display: flex;
            align-items: baseline;
            gap: 10px;
            justify-content: flex-end;
        }

        .tone-selector-area label {
            margin-bottom: 0;
        }


        #craftBiographyButton {
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            background-color: #FFA500;
            color: black;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(255, 165, 0, 0.5);
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            white-space: nowrap;
        }

        #craftBiographyButton:hover {
            background-color: #FF8C00;
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(255, 165, 0, 0.7);
        }

        .save-checkpoint-area {
            text-align: center;
            margin-top: 20px;
        }

         #recordButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007AFF;
            color: white;
            border: none;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        #recordButton:hover {
            background-color: #0059b3;
        }
        #audioPlayback {
            margin-top: 10px;
        }


    </style>
    <script>
        // All the code here is to ensure it is loaded at the top level scope.
        let uploaded_content = "";
        let storyUpload;
        let biographyOutline;
        let mediaRecorder;
        let audioChunks = [];

        function submitPrompt() {
            let userInput = document.getElementById("userPrompt").value;
            let chatOutput = document.getElementById("chatOutput");

            chatOutput.textContent = "Loading...";
            sendToOpenAI(userInput, chatOutput, uploaded_content);
            document.getElementById("userPrompt").value = "";
        }

         function sendToOpenAI(userInput, chatOutput, fileContent) {
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');

            fetch("/waltx/walt_analyze", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
                 body: "user_query=" + encodeURIComponent(userInput) + "&uploaded_content=" + encodeURIComponent(fileContent)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    chatOutput.textContent = "Error: " + data.error;
                } else {
                    chatOutput.textContent = data.response;
                    if (data.biography_outline) {
                        biographyOutline = data.biography_outline;
                        updateBiographyOutlineDisplay();
                    }
                    if (data.audio_url) {
                        playWaltAudio(data.audio_url);
                    }
                }
            })
            .catch(error => {
                chatOutput.textContent = "Error: " + error.message;
            });
        }

        function playWaltAudio(audioURL) {
            const audioPlayer = document.getElementById('audioPlayback');
            audioPlayer.src = audioURL;
            audioPlayer.play().catch(e => {
                console.error("Error playing audio:", e);
                alert("Audio playback failed. Please ensure your browser supports audio playback and that the audio file is accessible.");
            });
        }


         function getStoryBoard(){
            let chatOutput = document.getElementById("chatOutput").textContent;
            return chatOutput
         }

       function saveTextAsFile() {
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');
             let chatOutput = document.getElementById("chatOutput");

            chatOutput.textContent = "Processing Checkpoint and Creating File... Please wait.";

            fetch("/waltx/create_checkpoint", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error creating checkpoint: " + data.error);
                    chatOutput.textContent = "API Error: " + data.error;
                } else {
                    const fileContent = data["checkpoint_data"];

                    chatOutput.textContent += "\n\nCheckpoint file created and download started.";

                    console.log("fileContent from server", fileContent)

                    const textFileAsBlob = new Blob([fileContent], { type: 'text/plain' });
                    const fileNameToSaveAs = "sessionStory.txt";

                    const downloadLink = document.createElement("a");
                    downloadLink.download = fileNameToSaveAs;
                    downloadLink.innerHTML = "Download File";
                    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                    downloadLink.style.display = "none";

                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                 }
            })
            .catch(error => {
                chatOutput.textContent = "Fetch Error: " + error.message;
            });
        }

        function craftBiography() {
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');
            let chatOutput = document.getElementById("chatOutput");
            chatOutput.textContent = "Crafting Biography... Please wait.  This may take a minute.";

            fetch("/waltx/craft_biography", {
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error crafting biography: " + data.error);
                    chatOutput.textContent = "Error crafting biography: " + data.error;
                } else {
                    chatOutput.innerHTML = data.api_response;

                    const fileContent = data.api_response.replace(/<br>/g, '\n');
                    const textFileAsBlob = new Blob([fileContent], { type: 'text/plain' });
                    const fileNameToSaveAs = data.file_download_name || "Full_biography.txt";
                    const downloadLink = document.createElement("a");
                    downloadLink.download = fileNameToSaveAs;
                    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                    downloadLink.style.display = "none";
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    chatOutput.textContent += "\n\nBiography crafted and download started.";
                }
            })
            .catch(error => chatOutput.textContent = "Error crafting biography: " + error.message);
        }


         function sendCheckpointData(fileContent) {
              try {
                function getCookie(name) {
                    const value = `; ${document.cookie}`;
                    const parts = value.split(`; ${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
                }

                const csrfToken = getCookie('csrf_token');

                fetch("/waltx/continue_bio_start", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                        "X-CSRFToken": csrfToken
                    },
                    body: "checkpoint_data=" + encodeURIComponent(fileContent)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        document.getElementById("chatOutput").textContent = "Error: " + data.error;
                    } else {
                        document.getElementById("chatOutput").textContent = data.initial_message;
                        if (data.biography_outline) {
                            biographyOutline = data.biography_outline;
                            updateBiographyOutlineDisplay();
                        }
                        sendLoadMessage();
                    }
                })
                .catch(error => {
                    document.getElementById("chatOutput").textContent = "Error loading checkpoint.";
                });
            } catch (error) {
                console.error("Error in sendCheckpointData:", error);
                document.getElementById("chatOutput").textContent = "Error loading checkpoint.";
            }
        }

        function sendLoadMessage() {
            let chatOutput = document.getElementById("chatOutput");
            chatOutput.textContent ="Oh I see! I'd forgotten what we already did. Wonderful";
         }
         function uploadStory() {
              console.log("Firing Upload Story Trigger");
              if (storyUpload) {
                  storyUpload.click();
               } else {
                 console.error("storyUpload element not found");
               }

           }


        function updateBiographyOutlineDisplay() {
            const outlineDiv = document.getElementById('biographyOutline');
            if (!biographyOutline || !outlineDiv) return;

            let outlineHTML = '<h2>Biography Outline</h2><ul>';
            biographyOutline.forEach(chapter => {
                const statusClass = chapter.status === 'Complete' ? 'chapter-status-complete' : 'chapter-status-tbd';
                outlineHTML += `<li><span class="chapter-title">Chapter ${chapter.chapter}: ${chapter.title}</span> - <span class="${statusClass}">${chapter.status}</span></li>`;
            });
            outlineHTML += '</ul>';
            outlineDiv.innerHTML = outlineHTML;
        }

        function startRecording() {
            console.log('startRecording() START');
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    console.log('getUserMedia() success - stream obtained', stream);
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = event => {
                        console.log('ondataavailable - event.data:', event.data);
                        console.log('ondataavailable - event.data.size:', event.data.size);
                        audioChunks.push(event.data);
                        console.log('ondataavailable - audioChunks.length after push:', audioChunks.length);
                    };
                    mediaRecorder.onstop = async function() { // Make onstop async
                        console.log('mediaRecorder.onstop - STARTING - waiting for recording to fully stop');
                        stopRecording(); // Call stopRecording to ensure state is updated
                        await new Promise(resolve => setTimeout(resolve, 100)); // Small delay to ensure all data is processed
                        console.log('mediaRecorder.onstop - AFTER DELAY - calling processAudio()');
                        processAudio(); // Now call processAudio after delay
                    };
                    mediaRecorder.start();
                    document.getElementById('recordButton').textContent = 'Stop Recording';
                    console.log('Recording started - mediaRecorder.state:', mediaRecorder.state);
                }).catch(error => {
                    console.error("Error accessing microphone:", error);
                    alert("Microphone access denied or not available.");
                    console.log('startRecording() - getUserMedia ERROR', error);
                });
        }

        function stopRecording() {
            console.log('stopRecording() START - mediaRecorder:', mediaRecorder);
            return new Promise(resolve => { // Return a Promise
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    console.log('stopRecording() - mediaRecorder.stop() called');
                    mediaRecorder.onstop = function() { // Re-define onstop to resolve promise
                        console.log('mediaRecorder.onstop - INSIDE stopRecording() - recording actually stopped');
                        document.getElementById('recordButton').textContent = 'Speak to WaltX';
                        console.log('Recording stopped - mediaRecorder.state:', mediaRecorder.state);
                        resolve(); // Resolve promise when really stopped
                    };
                    mediaRecorder.stop();
                } else {
                    console.log('stopRecording() - mediaRecorder not recording or not initialized');
                    resolve(); // Resolve immediately if not recording
                }
            });
        }


        async function processAudio() { // Make processAudio async
            console.log('processAudio() START - audioChunks.length:', audioChunks.length);

            if (!mediaRecorder || mediaRecorder.state === 'recording') {
                await stopRecording(); // Await stopRecording promise
                alert("Please stop recording before processing.");
                console.log('processAudio() - mediaRecorder still recording or not initialized - STOPPED IT');
                return;
            }

             if (audioChunks.length === 0) {
                alert("No audio recorded.");
                console.log('processAudio() - audioChunks.length is 0');
                return;
            }

            console.log('Audio processing started, chunk length:', audioChunks.length);

            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const formData = new FormData();
            formData.append('audio', audioBlob, 'user_audio.webm');

            let chatOutput = document.getElementById("chatOutput");
            chatOutput.textContent = "Transcribing audio...";

            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');


            fetch('/waltx/transcribe_audio', {
                method: 'POST',
                headers: {
                     'X-CSRFToken': csrfToken,
                },
                body: formData,
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    chatOutput.textContent = "Transcription Error: " + data.error;
                    console.log('processAudio() - transcription API error:', data.error);
                } else {
                    document.getElementById('userPrompt').value = data.transcription;
                    chatOutput.textContent = "Audio transcribed. Please submit your prompt.";
                    console.log('processAudio() - transcription success, transcription:', data.transcription);
                }
            })
            .catch(error => {
                chatOutput.textContent = "Fetch error during transcription: " + error.message;
                 console.error('processAudio() - fetch error during transcription:', error);
            });
             audioChunks = [];
        }


        function toggleRecord() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecording().then(processAudio); // Call processAudio after stop promise resolves
            } else {
                startRecording();
            }
        }


        document.addEventListener('DOMContentLoaded', function() {
            storyUpload = document.getElementById("story_upload");
            biographyOutline = {{ biography_outline|tojson }};
            updateBiographyOutlineDisplay();
            const chatOutput = document.getElementById("chatOutput");
            const initialMessage = "{{ initial_message|default('') | safe }}";

            if (initialMessage) {
                chatOutput.textContent = initialMessage;
            }


             console.log("Story Upload: Document is loaded");
            if (storyUpload) {
               storyUpload.addEventListener("change", function(event) {
                    console.log("Event Listener Triggered");
                    if (this.files && this.files[0]) {
                      const fileInput = document.getElementById("story_upload");
                      const chatOutput = document.getElementById("chatOutput");

                      const file = fileInput.files[0];

                       const reader = new FileReader();
                         reader.onload = function(event) {
                               try{
                                    console.log ("Story Uploaded to the Chat Output", event.target.result);
                                    uploaded_content = event.target.result;
                                    chatOutput.textContent = "Loading Checkpoint...";
                                     sendCheckpointData(event.target.result);
                                }

                                catch (error){
                                    chatOutput.textContent = "Error loading file: " + event.target.error;
                                }
                          };

                          reader.onerror = function(event) {
                             chatOutput.textContent = "Error reading file: " + event.target.error;
                              console.error("Error reading file:", event.target.error);
                         };

                         reader.readAsText(file);
                      }
                   })
             } else {
                console.log("Story Upload does not exist")
             }
         })

         window.onload = function() {
             // document.getElementById("chatOutput").textContent = "";
         };
     </script>
 <body>
     <h1>Walt the Biographer</h1>
     <p class="tagline">I want to write your story!</p>

        <div id="uploadButtonContainer">
         <button id="uploadButton" onclick="uploadStory()">Start at last Checkpoint</button>
     </div>
     <input type="file" id="story_upload" name="story_upload" accept=".txt, .walt">

     <div class="chat-container">
          <div class="chat-area">
             <h2 class="chat-title">Walt</h2>
             <div class="chat-output" id="chatOutput">
                 <audio id="audioPlayback" controls></audio>
             </div>
         </div>
         <div class="chat-area">
             <h2 class="chat-title">Your Prompts</h2>
             <div class="prompt-area">
                  <button id="recordButton" onclick="toggleRecord()">Speak to WaltX</button>
                 <textarea id="userPrompt" placeholder="Enter your prompt" rows="13"></textarea>
                 <button id="submitButton" onclick="submitPrompt()">Submit</button>
             </div>
         </div>
     </div>

     <h3 class="dataNote">Note: No data is saved by this application, the only memory is through this file alone.</h3>

     <div class="save-checkpoint-area">
         <button id="saveButton" onclick="saveTextAsFile()">Create Checkpoint File</button>
     </div>

     <div class="craft-area-container">
         <div class="tone-and-craft-group">
             <div class="tone-selector-area">
                 <label for="toneSelector">Biography Tone:</label>
                 <select id="toneSelector">
                     <option value="default">Default</option>
                     <option value="humorous">Humor</option>
                     <option value="reflective">Reflective</option>
                     <option value="dramatic">Dramatic</option>
                     <option value="inspirational">Inspirational</option>
                 </select>
             </div>
         </div>
          <div class="checkpoint-area">
             <div>
                 <button id="craftBiographyButton" onclick="craftBiography()">Craft Biography</button>
             </div>
         </div>
     </div>


     <div id="sessionSummary"></div>
 </body>
 </html>

--- FILE: waltx/templates/walt_splashx.html ---

<!-- file: walt/templates/walt_splash.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Walt Biographer</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7; /* Very light grey background */
            color: #333; /* Dark grey text for readability */
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex; /* Enable flexbox for body */
            justify-content: center;
            align-items: center;
             -webkit-font-smoothing: antialiased; /* For smoother fonts on macOS/iOS */
            -moz-osx-font-smoothing: grayscale;
        }

        .splash-container {
            display: flex; /* Flex container for image/title and buttons */
            width: 80%; /* Adjust as needed, max width of splash screen */
            max-width: 1200px;
            height: 70%; /* Adjust as needed, max height of splash screen */
            max-height: 800px;
            border-radius: 15px; /* More rounded corners */
            background: #fff; /* White splash container */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.08); /* Lighter shadow */
            overflow: hidden; /* Clip any overflowing content */
        }

        .splash-left {
            flex: 1; /* Take 50% of the container width */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px; /* Increased padding */
            text-align: center;
        }

        .splash-right {
            flex: 1; /* Take 50% of the container width */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px; /* Increased padding */
            background-color: #f0f0f0; /* Very light grey right side */
        }


        .splash-image {
            max-width: 80%; /* Control image size within its container */
            max-height: 60%;
            height: auto;
            margin-bottom: 25px; /* Increased margin */
        }

        h1 {
            color: #007AFF; /* Apple Blue */
            font-size: 2.8em; /* Slightly larger title */
            margin: 0; /* Remove default margins */
            font-weight: 600;
        }

        .splash-tagline {
            font-style: italic;
            color: #555; /* Medium grey tagline */
            font-size: 1.5em; /* Adjust font size as needed */
            margin-bottom: 20px; /* Space below tagline */
        }

        .splash-get-started {
            color: #777; /* Lighter grey "Get Started" */
            font-size: 1.1em; /* Slightly larger "Get Started" */
            margin-bottom: 15px; /* Space below "Get Started" */
        }


        .splash-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Increased gap */
            width: 85%; /* Buttons width relative to right container */
            max-width: 450px; /* Max width for buttons */
            margin-top: 15px; /* Space above buttons - reduced slightly */
        }

        .splash-button {
            padding: 16px 24px; /* Larger buttons */
            font-size: 1.3em;
            cursor: pointer;
            background-color: #007AFF; /* Apple Blue buttons */
            color: white;
            border: none;
            border-radius: 10px; /* More rounded corners */
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            white-space: nowrap; /* Prevent button text wrapping */
            box-shadow: 0 3px 6px rgba(0, 122, 255, 0.3); /* Apple Blue shadow */
            font-weight: 500;
        }

        .splash-button:hover {
            background-color: #0059b3; /* Darker Apple Blue on hover */
            transform: scale(1.03); /* Slight scale up on hover */
            box-shadow: 0 4px 8px rgba(0, 122, 255, 0.5); /* Enhanced shadow on hover */
        }

        #story_upload {
            display: none; /* Hide the file input initially */
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .splash-container {
                flex-direction: column; /* Stack image/title and buttons vertically */
                width: 95%; /* Take up more width on smaller screens */
                height: auto; /* Adjust height to content */
                text-align: center; /* Center text on smaller screens */
            }
            .splash-left, .splash-right {
                flex: none; /* No flex for stacked layout */
                width: 100%; /* Full width when stacked */
            }
             .splash-image {
                max-width: 60%; /* Smaller image on mobile */
                max-height: 50%;
             }
            h1 {
                font-size: 2.3em; /* Smaller title on mobile */
            }
            .splash-tagline {
                font-size: 1.3em; /* Smaller tagline on mobile */
            }
             .splash-buttons {
                width: 90%; /* Wider buttons on mobile */
            }
             .splash-left, .splash-right {
                padding: 20px; /* Reduce padding on smaller screens */
            }
        }
    </style>
    <script>
        function beginNewBiography() {
            console.log("beginNewBiography function called!"); // ADDED LOG
            // Changed to fetch API call
            fetch("/waltx/new_bio_start", { // <-- CORRECTED URL to /waltx/new_bio_start
                method: "GET",
                headers: {
                    'Content-Type': 'application/json' // Expecting JSON response
                },
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error starting new biography: " + data.error);
                } else {
                    console.log("Redirecting to /waltx/app"); // ADDED LOGGING BEFORE REDIRECT
                    window.location.href = "/waltx/app"; // Redirect to /waltx/app, the main app route  <--- CHANGED LINE to /waltx/app
                }
            })
            .catch(error => {
                alert("Error starting new biography.");
                console.error("Fetch error:", error);
            });
        }

        function loadCheckpointFile() {
            console.log("loadCheckpointFile function called!"); // ADDED LOG
            document.getElementById('story_upload').click(); // Trigger file input
        }

        document.addEventListener('DOMContentLoaded', function() {
            const storyUpload = document.getElementById("story_upload");
            if (storyUpload) {
                storyUpload.addEventListener("change", function(event) {
                    if (this.files && this.files[0]) {
                        const file = this.files[0];
                        const reader = new FileReader();

                        reader.onload = function(event) {
                            const fileContent = event.target.result;
                            sendCheckpointData(fileContent); // Call existing function to load checkpoint
                        };
                        reader.onerror = function(event) {
                            alert("Error reading file: " + event.target.error);
                            console.error("Error reading file:", event.target.error);
                        };
                        reader.readAsText(file);
                    }
                });
            }
        });

        function sendCheckpointData(fileContent) {
            // Get CSRF token from cookie
            function getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
            }

            const csrfToken = getCookie('csrf_token');

            fetch("/waltx/continue_bio_start", { // Corrected path to "/waltx/continue_bio_start"  <-- CORRECTED URL to /waltx/continue_bio_start
                method: "POST",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    "X-CSRFToken": csrfToken
                },
                body: "checkpoint_data=" + encodeURIComponent(fileContent)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert("Error loading checkpoint: " + data.error);
                } else {
                     console.log("Redirecting to /waltx/app"); // ADDED LOGGING BEFORE REDIRECT
                    window.location.href = "/waltx/app"; // Redirect to  /waltx/app, the main app route  <--- CHANGED LINE to /waltx/app
                }
            })
            .catch(error => {
                alert("Error loading checkpoint.");
                console.error("Fetch error:", error);
            });
        }


    </script>
</head>
<body>
    <div class="splash-container">
        <div class="splash-left">
            <img src="{{ url_for('static', filename='images/walt.png') }}" alt="Walt Biographer" class="splash-image">
            <h1>Walt, the AI Biographer</h1>
        </div>
        <div class="splash-right">
            <p class="splash-tagline">I want to write your unique story!</p> <p class="splash-get-started">Get Started</p>
            <div class="splash-buttons">
                <button class="splash-button" onclick="beginNewBiography()">Begin New Bio</button>
                <button class="splash-button" onclick="loadCheckpointFile()">Load Your Checkpoint file</button>
            </div>
        </div>
    </div>
    <input type="file" id="story_upload" name="story_upload" accept=".txt, .walt">
</body>
</html>

--- FILE: waltx/walt_prompts/bio_creator_prompt.txt ---


Take all the following input and write a single brilliant and thoughtful complete biography of the person incorporating everything provided.
Do not repeat everything sent to you back.  Just incorporate all the information into a single biography.
Do not fill in chapters that have insufficient information to draft. Simply include the chapter in the outline and mark it as "TBD".
You may rework previous chapters already written if the newest conversation improves them.
After the biography, include a list of each and every facts accumulated so far about the person as attribute value pairs such as "Born On: 25 December 1923:, "Born In: Columbus Ohio".


--- FILE: waltx/walt_prompts/continue.txt ---

Look in the attached information and extract the users first name.   Welcome the user by name and ask if they are ready to continue with their interview.


--- FILE: waltx/walt_prompts/walt_promptold.txt ---

--- START OF FILE walt_prompt.txt ---
Personality: You are Walt, a biographer inspired by Oprah. Be friendly, warm, genuinely curious, and make the interview feel like a comfortable chat. Use light humor and enthusiasm naturally.

Identity: Walt.  Friendly, enthusiastic AI biographer.

Process:
First: For *new* conversations, greet warmly and ask for the user's name naturally (e.g., "It's wonderful to meet you!  Could I get your name?"). For *returning* users, welcome them back, summarize progress.

Second: Early on, thoughtfully ask about their desired legacy: "What's the *one thing* you hope people will remember most about you?". Keep this theme in mind.

Third: Be a good listener! Based on what the user shares, *suggest* the most relevant biography chapter to explore next. Make it a suggestion, not an order (e.g., "That's interesting about [their story]! Sounds like 'Origins - Early Life & Influences'.  Would you like to share more about your childhood, or another part of your story?"). Be flexible!

Fourth: Ask open-ended, insightful questions to encourage storytelling, but be concise.  Think like a curious friend. Use brief questions like:
- "Tell me more..."
- "What were you feeling?"
- "Who was involved?"
- "What did you learn?"
Occasionally, use Oprah-style reflective questions, but sparingly.

Fifth: Show you're listening. Briefly summarize key facts periodically to check understanding (e.g., "So, you grew up in [place], and [person] was key.  Accurate?"). Be concise, ensure they feel heard.

Sixth: Celebrate progress briefly! Acknowledge chapter completion concisely and positively (e.g., "Great, vivid picture of your early life!" or "Powerful story! Essence captured.  Doing great!").

Tone: Warm, encouraging, conversational, and concise. Imagine a friendly coffee shop chat, but efficient. Avoid overly formal or robotic language. Inject personality and genuine interest concisely. Emojis sparingly.

Remember: Co-create biography *with* the user, making it insightful and pleasant, but efficient. Be a supportive guide and enthusiastic listener, concisely.

Examples of concise questions:
- Shaping experience (pain or joy)?
- One truth for the world to know?
- When felt most alive?
- Belief worth standing alone for?
- Hardest lesson, wouldn’t trade?
- Younger self's surprise now?
- One self-mystery?
- Deepest love/connection?
- Three words for your soul?
- Moment to relive (not change)?

Outline: (Guide, be flexible)
1. Hook – Defining Moment
2. Origins – Early Life & Influences
3. Call to Action – First Big Decision
4. Rising Conflict – Struggles & Growth
5. Climax – Defining Achievements

--- NEW SECTION - CONCISE INSTRUCTIONS FOR FOLLOW-UP QUESTIONS ---

For follow-up questions:

*   Integrate questions directly into your conversational response.
*   Phrase as natural, friendly questions Walt would ask.
*   Keep questions very brief and focused. Aim for single, direct questions.
*   Use a warm, concise, engaging tone.
*   Example of concise integration:  "Montreal sounds pivotal!  What year did you arrive?  Key people in hockey then?"
*   Avoid: Formal introductions, numbered lists, verbose phrasing.

--- END OF FILE walt_prompt.txt ---


--- FILE: waltx/walt_prompts/welcome.txt ---

Greet the user as a concise, charismatic, elegant, and genuinely interested, gentleman would.   For example, "I'm so glad to see you.  My name is Walt and I'd he honored to learn all about you as I write your biograpy".  Ask their name and where and when they were born.


--- FILE: waltx/walt_prompts/write_bio.txt ---

You're a gifted writer and world-class biographer.   
Take all following input and write a compelling and complete biography of this person using the outline provided.
Integrate all the stories, ideas, content and facts that have been provided.
The resulting work should be an accurate, compelling and complete story, not missing any details.
At the end include a list of all facts that have been provided.
Mark the end of work with the words "The End of the Biography!"


--- FILE: waltx/walt_prompts/walt_prompt.txt ---

Personality: You are Walt, a biographer inspired by Oprah. Be friendly, warm, genuinely curious, and concise.  Make the interview feel like a comfortable chat. Use light humor and enthusiasm naturally.

Identity: Walt.  charismatic, enthusiastic biographer and friend.

Process:
First: Examine the outline.  If the hook hasn't been established, always start there with the question "What's the *one thing* you hope people will remember most about you?".  Otherwise, select one chapter that us marked TBD and ask an open ended question to get them talking about the topic. Focus questions on collecting information to write that chapter.
Second: Dig deeper into their answer to understand why they answered that way.
Third: If not offered, ask for facts relevant to the conversation including names, dates, places and major events.
Fourth: Be a good listener! Follow up questions and surprising information with more follow-up questions to expand on the subject.
Fifth, be an active listener.  Concisely confirm what you heard and be supportive. Use follow-on questions like a curious friend. Use brief questions like:
- "Tell me more..."
- "What were you feeling?"
- "Who was involved?"
- "What did you learn?"
Occasionally, use Oprah-style reflective questions, but sparingly.

Tone: Warm, encouraging, conversational, and concise. Imagine a friendly coffee shop chat, but efficient. Avoid overly formal or robotic language. Inject personality and genuine interest concisely. Emojis sparingly.

Remember: Co-create biography *with* the user, making it insightful and pleasant, but efficient. Be a supportive guide and enthusiastic listener, concisely.

Examples of concise questions:
- What was a shaping experience (pain or joy)?
- What's one truth for the world to know?
- When did you felt most alive?
- Belief worth standing alone for?
- Hardest lesson, wouldn’t trade?
- Younger self's surprise now?
- One self-mystery?
- Deepest love/connection?
- Three words for your soul?
- Moment to relive (not change)?

Outline: (Guide, be flexible)
1. Hook – Defining Moment
2. Origins – Early Life & Influences
3. Call to Action – First Big Decision
4. Rising Conflict – Struggles & Growth
5. Climax – Defining Achievements

--- NEW SECTION - CONCISE INSTRUCTIONS FOR FOLLOW-UP QUESTIONS ---

For follow-up questions:

*   Integrate questions directly into your conversational response.
*   Phrase as natural, friendly questions Walt would ask.
*   Keep questions very brief and focused. Aim for single, direct questions.
*   Use a warm, concise, engaging tone.
*   Example of concise integration:  "Montreal sounds pivotal!  What year did you arrive?  Key people in hockey then?"
*   Avoid: Formal introductions, numbered lists, verbose phrasing.


--- STATIC FILES ---

File: static/.DS_Store, Mime Type: unknown
File: static/images/.DS_Store, Mime Type: unknown
File: static/images/walt.png, Mime Type: image/png
File: static/images/hero-image.jpg, Mime Type: image/jpeg
File: static/images/jeffsart/racecars.jpeg, Mime Type: image/jpeg
File: static/icons/.DS_Store, Mime Type: unknown
File: static/icons/dewar-flask.jpeg, Mime Type: image/jpeg
File: static/icons/amber-button.jpeg, Mime Type: image/jpeg
File: static/icons/green-button.jpeg, Mime Type: image/jpeg
File: static/icons/placeholder.jpeg, Mime Type: image/jpeg
File: static/icons/black-off-button.jpeg, Mime Type: image/jpeg
File: static/icons/red-button.jpeg, Mime Type: image/jpeg
